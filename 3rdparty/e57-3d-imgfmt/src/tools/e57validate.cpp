/*================================================================
 * Validator for ASTM Standard E57 format v1.0.
 *
 * Copyright (C) 2010 Kevin Ackley (kackley@gwi.net)
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

???
- set maxWarning=0 is same as suppress
- info about declaration and use of extension fields
- order of DateTime,timestamps
- guid use, def, references
- guids with unicode
- other strings with unicode
- image2d acquisition time too different from associated 3d time
- outside bounding box
- bbox not tight
- bbox coord system diff than points
- element names with unicode
- invalid point fields not set to constant value
- point fields that are completely invalid
- duplicate row/col/return occurances
- out of bound row/col/return indices
- bounds of values not tight
- negative timestamp
- fixed point coordinate is susp
- suggest invalid point coords be set to min
- errorId, with suppression list
- max count for each errorId
- use "value=123 is out of bounds" style
- bitset suppress message
- round code in demowrite01 for scan bounds (others?)


-e     suppress printing of all error messages
-e=<N> print a maximum of N messages for each error message code
-w     suppress printing of all warning messages
-w=<N> print a maximum of N messages for each warning message code
-s     suppress printing of all suspicious messages
-s=<N> print a maximum of N messages for each suspicious message code
-i     suppress printing of all informational messages
-i=<N> print a maximum of N messages for each informational message code
-m<DDDD> suppress printing of specific 4 digit message code DDDD.
-m<DDDD>=<N> print a maximum of N messages for specific 4 digit message code DDDD.



================================================================*/
#if defined(_MSC_VER) || defined(__APPLE__)
#   include <unordered_map>
#else
#   include <tr1/unordered_map>
using std::tr1::unordered_map;
#endif
#include <cstring>
using std::strlen;
#include <cmath>
using std::fabs;

#include "E57Foundation.h"
using namespace e57;
using namespace std;

/// Create whitespace of given length, for indenting printouts in dump() functions
inline std::string space(int n) {return(std::string(n,' '));}

//???
#include <sstream>
/// Convert number to decimal strings
template<class T>
std::string toString(T x) {std::ostringstream ss; ss << x; return(ss.str());}
#if 0 // <rs> 2011-10-03 below definition gives problems if intXX_t type equal to native type
inline std::string toString(uint64_t x) {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(uint32_t x) {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(uint16_t x) {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(uint8_t x)  {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(int64_t x)  {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(int32_t x)  {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(int16_t x)  {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(int8_t x)   {std::ostringstream ss; ss << x; return(ss.str());}
#ifndef __GNUC__
inline std::string toString(int x)      {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(unsigned x) {std::ostringstream ss; ss << x; return(ss.str());}
#endif
inline std::string toString(float x)    {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(double x)   {std::ostringstream ss; ss << x; return(ss.str());}
inline std::string toString(bool x)     {std::ostringstream ss; ss << x; return(ss.str());}
#endif

/// Don't do any work if past specified maximumum message count (including expanding arguments).
/// Note: the do{}while(0) loop eats the trailing semicolon after macro expansion of "PRINT_MESSAGE(...);"
/// printMessage is called when messageCount is < 2 beyond allowed to allow suppression message to be printed.
#define PRINT_MESSAGE(messageNumber, n, msg, cvp, index) do {                                   \
    if ((messageNumber) >= 0 && (messageNumber) < E57ValidatorOptions::MessageNumberCount) {    \
        messageCount_[(messageNumber)]++;                                                       \
        if (messageCount_[(messageNumber)] < options_.messagesAllowed[(messageNumber)]+2)       \
            printMessage((messageNumber), (n), (msg), (cvp), (index));                          \
    }                                                                                           \
} while (0)

//================================================================

struct E57ValidatorOptions {
    static const int MessageNumberCount = 5000;

    uint64_t    messagesAllowed[MessageNumberCount];

    E57ValidatorOptions() {
        for (int i = 0; i < MessageNumberCount; i++)
            messagesAllowed[i] = 100;
    };
};

//================================================================

struct CommandLineOptions {
    E57ValidatorOptions options;
    vector<ustring> inputFileNames;

            CommandLineOptions(){};
    void    parse(int argc, char** argv);
    void    usage(ustring msg);
};

void CommandLineOptions::usage(ustring msg)
{
    cerr << "Error in command line: " << msg << endl;
    cerr << "Usage:" << endl;
    cerr << "    e57validate [options] <e57_files>..." << endl;
    cerr << "    options:" << endl;
    cerr << "        -e     suppress printing of all error messages." << endl;
    cerr << "        -e=<N> print a maximum of N messages for each error message code." << endl;
    cerr << "        -w     suppress printing of all warning messages." << endl;
    cerr << "        -w=<N> print a maximum of N messages for each warning message code." << endl;
    cerr << "        -s     suppress printing of all suspicious messages." << endl;
    cerr << "        -s=<N> print a maximum of N messages for each suspicious message code." << endl;
    cerr << "        -i     suppress printing of all informational messages." << endl;
    cerr << "        -i=<N> print a maximum of N messages for each informational message code." << endl;
    cerr << "        -m<DDDD> suppress printing of specific 4 digit message code DDDD." << endl;
    cerr << "        -m<DDDD>=<N> print a maximum of N messages for specific 4 digit message code DDDD." << endl;
    cerr << "    For example:" << endl;
    cerr << "        e57validate scan0001.e57               // validate a file with default options" << endl;
    cerr << "        e57validate -i scan0001.e57            // suppress all informational messages" << endl;
    cerr << "        e57validate -w=10 scan0001.e57         // print up to 10 lines of each type of warning message" << endl;
    cerr << "        e57validate -m4003 scan0001.e57        // suppress message number 4003" << endl;
    cerr << "        e57validate -m4003=10 scan0001.e57     // print up to 10 lines of message number 4003" << endl;
    cerr << endl;
    exit(-1);
}

void CommandLineOptions::parse(int argc, char** argv)
{
    /// Skip program name
    argc--; argv++;

    /// Parse options until first char not '-'
    for (; argc > 0 && argv[0][0] == '-'; argc--,argv++) {
        if (argv[0][1] == 'e') {
            if (argv[0][2] == '\0') {
                /// Got "-e", so disable all error messages
                for (int i = 1000; i < 2000; i++)
                    options.messagesAllowed[i] = 0;
            } else {
                if (argv[0][2] != '=')
                    usage(ustring("bad option format in flag ") + argv[0]);

                for (size_t j = 3; j < strlen(argv[0]); j++) {
                    if (argv[0][j] < '0' || '9' < argv[0][j])
                        usage(ustring("bad decimal number in flag") + argv[0]);
                }

                int allowed = atoi(&argv[0][3]);
                for (int i = 1000; i < 2000; i++)
                    options.messagesAllowed[i] = allowed;
            }
        } else if (argv[0][1] == 'w') {
            if (argv[0][2] == '\0') {
                /// Got "-w", so disable all warning messages
                for (int i = 2000; i < 3000; i++)
                    options.messagesAllowed[i] = 0;
            } else {
                if (argv[0][2] != '=')
                    usage(ustring("bad option format in flag ") + argv[0]);

                for (size_t j = 3; j < strlen(argv[0]); j++) {
                    if (argv[0][j] < '0' || '9' < argv[0][j])
                        usage(ustring("bad decimal number in flag") + argv[0]);
                }

                int allowed = atoi(&argv[0][3]);
                for (int i = 2000; i < 3000; i++)
                    options.messagesAllowed[i] = allowed;
            }
        } else if (argv[0][1] == 's') {
            if (argv[0][2] == '\0') {
                /// Got "-s", so disable all suspicious messages
                for (int i = 3000; i < 4000; i++)
                    options.messagesAllowed[i] = 0;
            } else {
                if (argv[0][2] != '=')
                    usage(ustring("bad option format in flag ") + argv[0]);

                for (size_t j = 3; j < strlen(argv[0]); j++) {
                    if (argv[0][j] < '0' || '9' < argv[0][j])
                        usage(ustring("bad decimal number in flag") + argv[0]);
                }

                int allowed = atoi(&argv[0][3]);
                for (int i = 3000; i < 4000; i++)
                    options.messagesAllowed[i] = allowed;
            }
        } else if (argv[0][1] == 'i') {
            if (argv[0][2] == '\0') {
                /// Got "-s", so disable all informational messages
                for (int i = 4000; i < 5000; i++)
                    options.messagesAllowed[i] = 0;
            } else {
                if (argv[0][2] != '=')
                    usage(ustring("bad option format in flag ") + argv[0]);

                for (size_t j = 3; j < strlen(argv[0]); j++) {
                    if (argv[0][j] < '0' || '9' < argv[0][j])
                        usage(ustring("bad decimal number in flag") + argv[0]);
                }

                int allowed = atoi(&argv[0][3]);
                for (int i = 4000; i < 5000; i++)
                    options.messagesAllowed[i] = allowed;
            }
        } else if (argv[0][1] == 'm') {
            size_t j;
            for (j = 2; j < 6 && j < strlen(argv[0]); j++) {
                if (argv[0][j] < '0' || '9' < argv[0][j])
                    usage(ustring("bad decimal number in flag") + argv[0]);
            }
            if (j < 6)
                usage(ustring("bad option format in flag ") + argv[0]);
            int messageNumber = (argv[0][2]-'0')*1000 + (argv[0][3]-'0')*100 + (argv[0][4]-'0')*10 + (argv[0][5]-'0');


            int allowed = 0;
            if (strlen(argv[0]) > 6) {
                if (argv[0][6] != '=' || strlen(argv[0]) == 7)
                    usage(ustring("bad option format in flag ") + argv[0]);

                for (size_t j = 7; j < strlen(argv[0]); j++) {
                    if (argv[0][j] < '0' || '9' < argv[0][j])
                        usage(ustring("bad decimal number in flag") + argv[0]);
                }
                allowed = atoi(&argv[0][7]);
                for (int i = 4000; i < 5000; i++)
                    options.messagesAllowed[i] = allowed;
            }
            options.messagesAllowed[messageNumber] = allowed;
        } else
            usage(ustring("unknown option: ") + argv[0]);
    }

    /// Parse file names
    for (; argc > 0 && argv[0][0] != '-'; argc--,argv++)
        inputFileNames.push_back(argv[0]);

    if (inputFileNames.size() == 0)
        usage("missing file name");

	if (argc > 0)
        usage("no options after first file name");
}


//================================================================

struct GroupBuffers {
    static const size_t elementCount = (8*1024);

    int64_t*    idElementValue;
    int64_t*    startPointIndex;
    int64_t*    pointCount;
    double*     cartesianBoundsXMinimum;
    double*     cartesianBoundsXMaximum;
    double*     cartesianBoundsYMinimum;
    double*     cartesianBoundsYMaximum;
    double*     cartesianBoundsZMinimum;
    double*     cartesianBoundsZMaximum;
    double*     sphericalBoundsRangeMinimum;
    double*     sphericalBoundsRangeMaximum;
    double*     sphericalBoundsAzimuthStart;
    double*     sphericalBoundsAzimuthEnd;
    double*     sphericalBoundsElevationMinimum;
    double*     sphericalBoundsElevationMaximum;

    GroupBuffers() : idElementValue(NULL),
                     startPointIndex(NULL),
                     pointCount(NULL),
                     cartesianBoundsXMinimum(NULL),
                     cartesianBoundsXMaximum(NULL),
                     cartesianBoundsYMinimum(NULL),
                     cartesianBoundsYMaximum(NULL),
                     cartesianBoundsZMinimum(NULL),
                     cartesianBoundsZMaximum(NULL),
                     sphericalBoundsRangeMinimum(NULL),
                     sphericalBoundsRangeMaximum(NULL),
                     sphericalBoundsAzimuthStart(NULL),
                     sphericalBoundsAzimuthEnd(NULL),
                     sphericalBoundsElevationMinimum(NULL),
                     sphericalBoundsElevationMaximum(NULL) {};

    vector<SourceDestBuffer> allBuffers(ImageFile imf) {
        vector<SourceDestBuffer> dbufs;

        if (idElementValue)
            dbufs.push_back(SourceDestBuffer(imf, "idElementValue", idElementValue, elementCount, true, true));
        if (startPointIndex)
            dbufs.push_back(SourceDestBuffer(imf, "startPointIndex", startPointIndex, elementCount, true, true));
        if (pointCount)
            dbufs.push_back(SourceDestBuffer(imf, "pointCount", pointCount, elementCount, true, true));
        if (cartesianBoundsXMinimum)
            dbufs.push_back(SourceDestBuffer(imf, "cartesianBounds/xMinimum", cartesianBoundsXMinimum, elementCount, true, true));
        if (cartesianBoundsXMaximum)
            dbufs.push_back(SourceDestBuffer(imf, "cartesianBounds/xMaximum", cartesianBoundsXMaximum, elementCount, true, true));
        if (cartesianBoundsYMinimum)
            dbufs.push_back(SourceDestBuffer(imf, "cartesianBounds/yMinimum", cartesianBoundsYMinimum, elementCount, true, true));
        if (cartesianBoundsYMaximum)
            dbufs.push_back(SourceDestBuffer(imf, "cartesianBounds/yMaximum", cartesianBoundsYMaximum, elementCount, true, true));
        if (cartesianBoundsZMinimum)
            dbufs.push_back(SourceDestBuffer(imf, "cartesianBounds/zMinimum", cartesianBoundsZMinimum, elementCount, true, true));
        if (cartesianBoundsZMaximum)
            dbufs.push_back(SourceDestBuffer(imf, "cartesianBounds/zMaximum", cartesianBoundsZMaximum, elementCount, true, true));
        if (sphericalBoundsRangeMinimum)
            dbufs.push_back(SourceDestBuffer(imf, "sphericalBounds/rangeMinimum", sphericalBoundsRangeMinimum, elementCount, true, true));
        if (sphericalBoundsRangeMaximum)
            dbufs.push_back(SourceDestBuffer(imf, "sphericalBounds/rangeMaximum", sphericalBoundsRangeMaximum, elementCount, true, true));
        if (sphericalBoundsAzimuthStart)
            dbufs.push_back(SourceDestBuffer(imf, "sphericalBounds/azimuthStart", sphericalBoundsAzimuthStart, elementCount, true, true));
        if (sphericalBoundsAzimuthEnd)
            dbufs.push_back(SourceDestBuffer(imf, "sphericalBounds/azimuthEnd", sphericalBoundsAzimuthEnd, elementCount, true, true));
        if (sphericalBoundsElevationMinimum)
            dbufs.push_back(SourceDestBuffer(imf, "sphericalBounds/elevationMinimum", sphericalBoundsElevationMinimum, elementCount, true, true));
        if (sphericalBoundsElevationMaximum)
            dbufs.push_back(SourceDestBuffer(imf, "sphericalBounds/elevationMaximum", sphericalBoundsElevationMaximum, elementCount, true, true));

        return(dbufs);
    };

    ~GroupBuffers() {
        if (idElementValue)                     delete [] idElementValue;
        if (startPointIndex)                    delete [] startPointIndex;
        if (pointCount)                         delete [] pointCount;
        if (cartesianBoundsXMinimum)            delete [] cartesianBoundsXMinimum;
        if (cartesianBoundsXMaximum)            delete [] cartesianBoundsXMaximum;
        if (cartesianBoundsYMinimum)            delete [] cartesianBoundsYMinimum;
        if (cartesianBoundsYMaximum)            delete [] cartesianBoundsYMaximum;
        if (cartesianBoundsZMinimum)            delete [] cartesianBoundsZMinimum;
        if (cartesianBoundsZMaximum)            delete [] cartesianBoundsZMaximum;
        if (sphericalBoundsRangeMinimum)        delete [] sphericalBoundsRangeMinimum;
        if (sphericalBoundsRangeMaximum)        delete [] sphericalBoundsRangeMaximum;
        if (sphericalBoundsAzimuthStart)        delete [] sphericalBoundsAzimuthStart;
        if (sphericalBoundsAzimuthEnd)          delete [] sphericalBoundsAzimuthEnd;
        if (sphericalBoundsElevationMinimum)    delete [] sphericalBoundsElevationMinimum;
        if (sphericalBoundsElevationMaximum)    delete [] sphericalBoundsElevationMaximum;
    };
};

//================================================================

struct PointBuffers {
    static const size_t elementCount = (8*1024);

    double*  cartesianX;
    double*  cartesianY;
    double*  cartesianZ;
    double*  sphericalRange;
    double*  sphericalAzimuth;
    double*  sphericalElevation;
    int64_t* rowIndex;
    int64_t* columnIndex;
    int64_t* returnCount;
    int64_t* returnIndex;
    double*  timeStamp;
    double*  intensity;
    double*  colorRed;
    double*  colorGreen;
    double*  colorBlue;
    int8_t*  cartesianInvalidState;
    int8_t*  sphericalInvalidState;
    int8_t*  isTimeStampInvalid;
    int8_t*  isIntensityInvalid;
    int8_t*  isColorInvalid;

    PointBuffers() :  cartesianX(NULL),
                      cartesianY(NULL),
                      cartesianZ(NULL),
                      sphericalRange(NULL),
                      sphericalAzimuth(NULL),
                      sphericalElevation(NULL),
                      rowIndex(NULL),
                      columnIndex(NULL),
                      returnCount(NULL),
                      returnIndex(NULL),
                      timeStamp(NULL),
                      intensity(NULL),
                      colorRed(NULL),
                      colorGreen(NULL),
                      colorBlue(NULL),
                      cartesianInvalidState(NULL),
                      sphericalInvalidState(NULL),
                      isTimeStampInvalid(NULL),
                      isIntensityInvalid(NULL),
                      isColorInvalid(NULL) {};

    vector<SourceDestBuffer> allBuffers(ImageFile imf) {
        vector<SourceDestBuffer> dbufs;

        if (cartesianX)             dbufs.push_back(SourceDestBuffer(imf, "cartesianX", cartesianX, elementCount, true, true));
        if (cartesianY)             dbufs.push_back(SourceDestBuffer(imf, "cartesianY", cartesianY, elementCount, true, true));
        if (cartesianZ)             dbufs.push_back(SourceDestBuffer(imf, "cartesianZ", cartesianZ, elementCount, true, true));
        if (sphericalRange)         dbufs.push_back(SourceDestBuffer(imf, "sphericalRange", sphericalRange, elementCount, true, true));
        if (sphericalAzimuth)       dbufs.push_back(SourceDestBuffer(imf, "sphericalAzimuth", sphericalAzimuth, elementCount, true, true));
        if (sphericalElevation)     dbufs.push_back(SourceDestBuffer(imf, "sphericalElevation", sphericalElevation, elementCount, true, true));
        if (rowIndex)               dbufs.push_back(SourceDestBuffer(imf, "rowIndex", rowIndex, elementCount, true, true));
        if (columnIndex)            dbufs.push_back(SourceDestBuffer(imf, "columnIndex", columnIndex, elementCount, true, true));
        if (returnCount)            dbufs.push_back(SourceDestBuffer(imf, "returnCount", returnCount, elementCount, true, true));
        if (returnIndex)            dbufs.push_back(SourceDestBuffer(imf, "returnIndex", returnIndex, elementCount, true, true));
        if (timeStamp)              dbufs.push_back(SourceDestBuffer(imf, "timeStamp", timeStamp, elementCount, true, true));
        if (intensity)              dbufs.push_back(SourceDestBuffer(imf, "intensity", intensity, elementCount, true, true));
        if (colorRed)               dbufs.push_back(SourceDestBuffer(imf, "colorRed", colorRed, elementCount, true, true));
        if (colorGreen)             dbufs.push_back(SourceDestBuffer(imf, "colorGreen", colorGreen, elementCount, true, true));
        if (colorBlue)              dbufs.push_back(SourceDestBuffer(imf, "colorBlue", colorBlue, elementCount, true, true));
        if (cartesianInvalidState)  dbufs.push_back(SourceDestBuffer(imf, "cartesianInvalidState", cartesianInvalidState, elementCount, true, true));
        if (sphericalInvalidState)  dbufs.push_back(SourceDestBuffer(imf, "sphericalInvalidState", sphericalInvalidState, elementCount, true, true));
        if (isTimeStampInvalid)     dbufs.push_back(SourceDestBuffer(imf, "isTimeStampInvalid", isTimeStampInvalid, elementCount, true, true));
        if (isIntensityInvalid)     dbufs.push_back(SourceDestBuffer(imf, "isIntensityInvalid", isIntensityInvalid, elementCount, true, true));
        if (isColorInvalid)         dbufs.push_back(SourceDestBuffer(imf, "isColorInvalid", isColorInvalid, elementCount, true, true));
        return(dbufs);
    };

    ~PointBuffers() {
        if (cartesianX)            delete [] cartesianX;
        if (cartesianY)            delete [] cartesianY;
        if (cartesianZ)            delete [] cartesianZ;
        if (sphericalRange)        delete [] sphericalRange;
        if (sphericalAzimuth)      delete [] sphericalAzimuth;
        if (sphericalElevation)    delete [] sphericalElevation;
        if (rowIndex)              delete [] rowIndex;
        if (columnIndex)           delete [] columnIndex;
        if (returnCount)           delete [] returnCount;
        if (returnIndex)           delete [] returnIndex;
        if (timeStamp)             delete [] timeStamp;
        if (intensity)             delete [] intensity;
        if (colorRed)              delete [] colorRed;
        if (colorGreen)            delete [] colorGreen;
        if (colorBlue)             delete [] colorBlue;
        if (cartesianInvalidState) delete [] cartesianInvalidState;
        if (sphericalInvalidState) delete [] sphericalInvalidState;
        if (isTimeStampInvalid)    delete [] isTimeStampInvalid;
        if (isIntensityInvalid)    delete [] isIntensityInvalid;
        if (isColorInvalid)        delete [] isColorInvalid;
    };
};

//================================================================

struct BoundingBox {
    bool    notEmpty;
    double  minimum[3];
    double  maximum[3];

            BoundingBox();
            BoundingBox(double xMin0, double xMax0, double xMin1, double xMax1, double xMin2, double xMax2);
            BoundingBox(StructureNode bounds, ustring boundsName);
    void    addPoint(double x0, double x1, double x2);
    void    addPoint(double coords[3]);
    bool    contains(double x0, double x1, double x2);
    bool    contains(double coords[3]);
    void    dump(int indent = 0, std::ostream& os = std::cout);
};

BoundingBox::BoundingBox()
{
    notEmpty = false;
    for (unsigned i = 0; i < 3; i++) {
        minimum[i] = 0.0;
        maximum[i] = 0.0;
    }
}

BoundingBox::BoundingBox(double xMin0, double xMax0, double xMin1, double xMax1, double xMin2, double xMax2)
{
    notEmpty = true;
    minimum[0] = xMin0;
    maximum[0] = xMax0;
    minimum[1] = xMin1;
    maximum[1] = xMax1;
    minimum[2] = xMin2;
    maximum[2] = xMax2;

    /// If minimim is larger than maximum, then the bounding box is the empty set
    for (unsigned i = 0; i < 3; i++) {
        if (minimum[i] > maximum[i])
            notEmpty = false;
    }
}

BoundingBox::BoundingBox(StructureNode bounds, ustring boundsName)
{
    notEmpty = true;
    if (boundsName == "cartesianBounds") {
        minimum[0] = FloatNode(bounds.get("xMinimum")).value();
        maximum[0] = FloatNode(bounds.get("xMaximum")).value();
        minimum[1] = FloatNode(bounds.get("yMinimum")).value();
        maximum[1] = FloatNode(bounds.get("yMaximum")).value();
        minimum[2] = FloatNode(bounds.get("zMinimum")).value();
        maximum[2] = FloatNode(bounds.get("zMaximum")).value();
    } else if (boundsName == "sphericalBounds") {
        minimum[0] = FloatNode(bounds.get("rangeMinimum")).value();
        maximum[0] = FloatNode(bounds.get("rangeMaximum")).value();
        minimum[1] = FloatNode(bounds.get("azimuthStart")).value();
        maximum[1] = FloatNode(bounds.get("azimuthEnd")).value();
        minimum[2] = FloatNode(bounds.get("elevationMinimum")).value();
        maximum[2] = FloatNode(bounds.get("elevationMaximum")).value();
    } else if (boundsName == "indexBounds") {
        minimum[0] = static_cast<double>(IntegerNode(bounds.get("rowMinimum")).value());
        maximum[0] = static_cast<double>(IntegerNode(bounds.get("rowMaximum")).value());
        minimum[1] = static_cast<double>(IntegerNode(bounds.get("columnMinimum")).value());
        maximum[1] = static_cast<double>(IntegerNode(bounds.get("columnMaximum")).value());
        minimum[2] = static_cast<double>(IntegerNode(bounds.get("returnMinimum")).value());
        maximum[2] = static_cast<double>(IntegerNode(bounds.get("returnMaximum")).value());
    } else
        throw "unknown bounds type"; //???

    /// If minimim is larger than maximum, then the bounding box is the empty set
    for (unsigned i = 0; i < 3; i++) {
        if (minimum[i] > maximum[i])
            notEmpty = false;
    }
}

void BoundingBox::addPoint(double x0, double x1, double x2)
{
    double coords[3];
    coords[0] = x0;
    coords[1] = x1;
    coords[2] = x2;
    addPoint(coords);
}

void BoundingBox::addPoint(double coords[3])
{
    if (notEmpty) {
        for (unsigned i = 0; i < 3; i++) {
            if (coords[i] < minimum[i])
                minimum[i] = coords[i];
            if (coords[i] > maximum[i])
                maximum[i] = coords[i];
        }
    } else {
        notEmpty = true;
        for (unsigned i = 0; i < 3; i++) {
            minimum[i] = coords[i];
            maximum[i] = coords[i];
        }
    }
}

bool BoundingBox::contains(double x0, double x1, double x2)
{
    double coords[3];
    coords[0] = x0;
    coords[1] = x1;
    coords[2] = x2;
    return(contains(coords));
}

bool BoundingBox::contains(double coords[3])
{
    if (notEmpty) {
        for (unsigned i = 0; i < 3; i++) {
            if (coords[i] < minimum[i])
                return(false);
            if (coords[i] > maximum[i])
                return(false);
        }
        return(true);
    } else
        return(false);
}

void BoundingBox::dump(int indent, std::ostream& os)
{
    os << space(indent) << "notEmpty:     " << notEmpty << endl;
    for (unsigned i = 0; i < 3; i++)
        os << space(indent) << "coords[" << i << "]: minimum=" << minimum[i] << " maximum=" << maximum[i] << endl;
}

//================================================================

struct LineGroup {
    int64_t     lineIndex;

    bool        declaredStartDefined;
    bool        declaredCountDefined;
    bool        declaredCartesianBoundsDefined;
    bool        declaredSphericalBoundsDefined;

    int64_t     declaredStart;
    int64_t     declaredCount;
    BoundingBox declaredCartesianBounds;
    BoundingBox declaredSphericalBounds;

    int64_t     actualStart;
    int64_t     actualCount;
    BoundingBox actualCartesianBounds;
    BoundingBox actualSphericalBounds;

    LineGroup();
    void    dump(int indent = 0, std::ostream& os = std::cout);
};

LineGroup::LineGroup()
: lineIndex(0),
  declaredStartDefined(false),
  declaredCountDefined(false),
  declaredCartesianBoundsDefined(false),
  declaredSphericalBoundsDefined(false),
  declaredStart(0),
  declaredCount(0),
  actualStart(0),
  actualCount(0)
{}

void LineGroup::dump(int indent, std::ostream& os)
{
    os << space(indent) << "lineIndex:                      " << lineIndex << endl;
    os << space(indent) << "declaredStartDefined:           " << declaredStartDefined << endl;
    os << space(indent) << "declaredCountDefined:           " << declaredCountDefined << endl;
    os << space(indent) << "declaredCartesianBoundsDefined: " << declaredCartesianBoundsDefined << endl;
    os << space(indent) << "declaredSphericalBoundsDefined: " << declaredSphericalBoundsDefined << endl;
    if (declaredStartDefined)
        os << space(indent) << "declaredStart:                  " << declaredStart << endl;
    if (declaredCountDefined)
        os << space(indent) << "declaredCount:                  " << declaredCount << endl;
    if (declaredCartesianBoundsDefined) {
        os << space(indent) << "declaredCartesianBounds:        " << endl;
        declaredCartesianBounds.dump(indent+4, os);
    }
    if (declaredSphericalBoundsDefined) {
        os << space(indent) << "declaredSphericalBounds:        " << endl;
        declaredSphericalBounds.dump(indent+4, os);
    }

    if (declaredStartDefined)
        os << space(indent) << "actualStart:                    " << actualStart << endl;
    if (declaredCountDefined)
        os << space(indent) << "actualCount:                    " << actualCount << endl;
    if (declaredCartesianBoundsDefined) {
        os << space(indent) << "actualCartesianBounds:          " << endl;
        actualCartesianBounds.dump(indent+4, os);
    }
    if (declaredSphericalBoundsDefined) {
        os << space(indent) << "actualSphericalBounds:          " << endl;
        actualSphericalBounds.dump(indent+4, os);
    }
}

//================================================================

class LineGrouping {
public:
                LineGrouping(Node data3DNode);
    bool        isDefined() {return(isDefined_);};
    bool        isByRow() {return(isByRow_);};
    LineGroup*  findLineGroup(int64_t lineIndex);

    void        dump(int indent = 0, std::ostream& os = std::cout);
//================
private:
#if defined(_MSC_VER) || defined(__APPLE__)
    typedef std::unordered_map<int64_t, LineGroup> GroupsMap;
#else
    typedef std::tr1::unordered_map<int64_t, LineGroup> GroupsMap;
#endif

    bool        isDefined_;
    bool        isByRow_;
    GroupsMap   groups_;
};

LineGrouping::LineGrouping(Node data3DNode)
: isDefined_(false),  // By default isDefined_ == false, until successfully get to end of this function
  isByRow_(false)
{
    if (data3DNode.type() != E57_STRUCTURE)
        return;
    StructureNode data3D = StructureNode(data3DNode);

    /// From data3D, carefully get "pointGroupingSchemes/groupingByLine/idElementName" String
    if (!data3D.isDefined("pointGroupingSchemes/groupingByLine/idElementName"))
        return;
    Node idElementNameNode = data3D.get("pointGroupingSchemes/groupingByLine/idElementName");
    if (idElementNameNode.type() != E57_STRING)
        return;
    ustring idElementName = StringNode(idElementNameNode).value();
    if (idElementName == "rowIndex")
        isByRow_ = true;
    else if (idElementName == "columnIndex")
        isByRow_ = false;
    else
        return;

    /// From data3D, carefully get "pointGroupingSchemes/groupingByLine/groups" CompressedVector
    if (!data3D.isDefined("pointGroupingSchemes/groupingByLine/groups"))
        return;
    Node groupsNode = data3D.get("pointGroupingSchemes/groupingByLine/groups");
    if (groupsNode.type() != E57_COMPRESSED_VECTOR)
        return;
    CompressedVectorNode groups = CompressedVectorNode(groupsNode);

    /// Get prototype, check that it is a Structure and downcast
    if (groups.prototype().type() != E57_STRUCTURE)
        return;
    StructureNode proto = StructureNode(groups.prototype());

    /// Verify required elements exist
    if (!proto.isDefined("idElementValue"))
        return;

    /// Create struct to hold all dest buffers for fields that are used
    GroupBuffers gbufs = GroupBuffers();

    /// Allocate destination buffer for each teriminal element in proto tree
    for (int64_t i = 0; i < proto.childCount(); i++) {
        Node childn = proto.get(i);
        ustring childName = childn.elementName();

        if (childName == "idElementValue")
            gbufs.idElementValue = new int64_t[gbufs.elementCount];
        else if (childName == "startPointIndex")
            gbufs.startPointIndex = new int64_t[gbufs.elementCount];
        else if (childName == "pointCount")
            gbufs.pointCount = new int64_t[gbufs.elementCount];
        else if (childName == "cartesianBounds"){
            if (childn.type() != E57_STRUCTURE)
                return;
            StructureNode sn = StructureNode(childn);
            if (!sn.isDefined("xMinimum") || !sn.isDefined("xMaximum"))
                return;
            if (!sn.isDefined("yMinimum") || !sn.isDefined("yMaximum"))
                return;
            if (!sn.isDefined("zMinimum") || !sn.isDefined("zMaximum"))
                return;
            gbufs.cartesianBoundsXMinimum = new double[gbufs.elementCount];
            gbufs.cartesianBoundsXMaximum = new double[gbufs.elementCount];
            gbufs.cartesianBoundsYMinimum = new double[gbufs.elementCount];
            gbufs.cartesianBoundsYMaximum = new double[gbufs.elementCount];
            gbufs.cartesianBoundsZMinimum = new double[gbufs.elementCount];
            gbufs.cartesianBoundsZMaximum = new double[gbufs.elementCount];
        } else if (childName == "sphericalBounds"){
            if (childn.type() != E57_STRUCTURE)
                return;
            StructureNode sn = StructureNode(childn);
            if (!sn.isDefined("rangeMinimum") || !sn.isDefined("rangeMaximum"))
                return;
            if (!sn.isDefined("azimuthStart") || !sn.isDefined("azimuthEnd"))
                return;
            if (!sn.isDefined("elevationMinimum") || !sn.isDefined("elevationMaximum"))
                return;
            gbufs.sphericalBoundsRangeMinimum = new double[gbufs.elementCount];
            gbufs.sphericalBoundsRangeMaximum = new double[gbufs.elementCount];
            gbufs.sphericalBoundsAzimuthStart = new double[gbufs.elementCount];
            gbufs.sphericalBoundsAzimuthEnd = new double[gbufs.elementCount];
            gbufs.sphericalBoundsElevationMinimum = new double[gbufs.elementCount];
            gbufs.sphericalBoundsElevationMaximum = new double[gbufs.elementCount];
        } else
            ;  /// Ignore any unknown child element names
    }

//printf("calling groups read\n"); //???

    /// Get iterator that reads CompressedVector contents in blocks
    CompressedVectorReader reader = groups.reader(gbufs.allBuffers(groups.destImageFile()));

    size_t gotCount = 0;
    uint64_t blockStart = 0;
    do {
        /// Read a block of data into the buffers in pbufs
        gotCount = reader.read();
//printf("groups read, gotCount=%d\n", gotCount); //???

        /// Add entry into hash table for each record in CompressedVector
        for (size_t i = 0; i < gotCount; i++) {
            LineGroup lineGroup;

            /// For each defined value, copy into LineGroup structure
            if (gbufs.idElementValue)
                lineGroup.lineIndex = gbufs.idElementValue[i];
            if (gbufs.startPointIndex) {
                lineGroup.declaredStartDefined = true;
                lineGroup.declaredStart = gbufs.startPointIndex[i];
            }
            if (gbufs.pointCount) {
                lineGroup.declaredCountDefined = true;
                lineGroup.declaredCount = gbufs.pointCount[i];
            }
            if (gbufs.cartesianBoundsXMinimum) {
                lineGroup.declaredCartesianBoundsDefined = true;
                lineGroup.declaredCartesianBounds = BoundingBox(gbufs.cartesianBoundsXMinimum[i],
                                                                gbufs.cartesianBoundsXMaximum[i],
                                                                gbufs.cartesianBoundsYMinimum[i],
                                                                gbufs.cartesianBoundsYMaximum[i],
                                                                gbufs.cartesianBoundsZMinimum[i],
                                                                gbufs.cartesianBoundsZMaximum[i]);
            }
            if (gbufs.sphericalBoundsRangeMinimum) {
                lineGroup.declaredSphericalBoundsDefined = true;
                lineGroup.declaredSphericalBounds = BoundingBox(gbufs.sphericalBoundsRangeMinimum[i],
                                                                gbufs.sphericalBoundsRangeMaximum[i],
                                                                gbufs.sphericalBoundsAzimuthStart[i],
                                                                gbufs.sphericalBoundsAzimuthEnd[i],
                                                                gbufs.sphericalBoundsElevationMinimum[i],
                                                                gbufs.sphericalBoundsElevationMaximum[i]);
            }

            groups_.insert(GroupsMap::value_type(lineGroup.lineIndex, lineGroup));
        }

        blockStart += gotCount;
    } while (gotCount > 0);
    reader.close();

    /// If get here, we have successfully read the grouping
    isDefined_ = true;

//printf("close groups read\n"); //???
//dump(4); //???
}

LineGroup* LineGrouping::findLineGroup(int64_t lineIndex)
{
    GroupsMap::iterator iter = groups_.find(lineIndex);
    return(iter != groups_.end() ? &iter->second : NULL);
}

void LineGrouping::dump(int indent, std::ostream& os)
{
    os << space(indent) << "isDefined:     " << isDefined_ << endl;
    if (isDefined_) {
        os << space(indent) << "isByRow:       " << isByRow_ << endl;

        GroupsMap::iterator iter;
        for (iter = groups_.begin(); iter != groups_.end(); iter++) {
            os << space(indent) << "group[" << iter->first << "]:" << endl;
            iter->second.dump(indent+4, os);
        }
    }
}

//================================================================

class E57Validator {
public:
    E57Validator(E57ValidatorOptions opts, std::ostream& os = std::cout);

    void validate(ImageFile imf);

    uint64_t errorCount() const;
    uint64_t warningCount() const;
    uint64_t suspiciousCount() const;
    uint64_t informationalCount() const;
    uint64_t messageCount(int messageNumber) const;

    void dump(int indent = 0, std::ostream& os = std::cout) const;

//================
protected:
    std::ostream&       os_;
    E57ValidatorOptions options_;
    uint64_t            messageCount_[E57ValidatorOptions::MessageNumberCount];

    bool validateInteger(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateScaledInteger(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateFloat(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateDoubleFloat(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateNumeric(Node n, bool allowInteger, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateString(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateBlob(Node n);
    bool validateStructure(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateHomogeneousVector(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateHeterogeneousVector(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    bool validateCompressedVector(Node n);
    bool validateCodecs(Node n);
    bool validateCodec(CompressedVectorNode cv);
    void validateCodecInputs(Node n);
    void validateBitPackCodec(Node n);
    void validateE57Root(Node n);
    void validateData3D(Node n);
    void validateOriginalGuids(Node n);
    void validatePoints(Node n);
    void validatePointRecordContents(CompressedVectorNode cv, StructureNode proto, PointBuffers& pbufs);
    void validatePointGroupingSchemes(Node n);
    void validateGroupingByLine(Node n);
    void validateLineGroupRecords(Node n);
    void validateRigidBodyTransform(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void validateQuaternion(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void validateTranslation(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void validateImages2D(Node n);
    void validateVisualReferenceRepresentation(Node n);
    void validatePinholeRepresentation(Node n);
    void validateSphericalRepresentation(Node n);
    void validateCylindricalRepresentation(Node n);
    void validateCartesianBounds(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void validateSphericalBounds(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void validateIndexBounds(Node n);
	void validateIntensityLimits(Node n);	//added by sc
	void validateColorLimits(Node n);		//added by sc
    void validateDateTime(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void validateGuid(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void validateCoordinateMetadata(Node n);
    void validateExtensionElement(Node n, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void printMessage(int messageNumber, Node n, ustring msg, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
    void checkRequired(StructureNode sn, ustring name, CompressedVectorNode* cvp = NULL, uint64_t index = 0);
};

E57Validator::E57Validator(E57ValidatorOptions opts, std::ostream& os)
: options_(opts),
  os_(os)
{
    for (int i = 0; i < E57ValidatorOptions::MessageNumberCount; i++)
        messageCount_[i] = 0;
}

uint64_t E57Validator::errorCount() const {
    uint64_t total = 0;
    for (int i = 1000; i < 2000; i++)
        total += messageCount_[i];
    return(total);
}

uint64_t E57Validator::warningCount() const {
    uint64_t total = 0;
    for (int i = 2000; i < 3000; i++)
        total += messageCount_[i];
    return(total);
}

uint64_t E57Validator::suspiciousCount() const {
    uint64_t total = 0;
    for (int i = 3000; i < 4000; i++)
        total += messageCount_[i];
    return(total);
}

uint64_t E57Validator::informationalCount() const {
    uint64_t total = 0;
    for (int i = 4000; i < E57ValidatorOptions::MessageNumberCount; i++)
        total += messageCount_[i];
    return(total);
}

uint64_t E57Validator::messageCount(int messageNumber) const {
    if (0 < messageNumber && messageNumber < E57ValidatorOptions::MessageNumberCount)
        return(messageCount_[messageNumber]);
    else
        return(0);
}

void E57Validator::validate(ImageFile imf) {
    validateE57Root(imf.root());
}

//================================================================
bool E57Validator::validateInteger(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (n.type() != E57_INTEGER) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting Integer type", cvp, index);
        return(false);
    }

    IntegerNode in = IntegerNode(n);
    int64_t value = in.value();

    /// Check not outside declared bounds
    if (value > in.maximum()) {
        PRINT_MESSAGE(1000/*???*/, n, "Integer is greater than declared maximum", cvp, index);
        return(false);
    }
    if (value < in.minimum()) {
        PRINT_MESSAGE(1000/*???*/, n, "Integer is less than declared minimum", cvp, index);
        return(false);
    }

    /// Check if anything suspicious
    if (value > 1e12)
        PRINT_MESSAGE(3000/*???*/, n, "magnitude of Integer value is suspiciously large: " + toString(value), cvp, index);

    return(true);
}

bool E57Validator::validateScaledInteger(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (n.type() != E57_SCALED_INTEGER) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting ScaledInteger type", cvp, index);
        return(false);
    }

    ScaledIntegerNode sin = ScaledIntegerNode(n);
    int64_t rawValue = sin.rawValue();
    double scale = sin.scale();
    double offset = sin.offset();
    double scaledValue = sin.scaledValue();

    /// Check not outside declared bounds
    if (rawValue > sin.maximum()) {
        PRINT_MESSAGE(1000/*???*/, n, "ScaledInteger rawValue is greater than declared maximum: " + toString(rawValue), cvp, index);
        return(false);
    }
    if (rawValue < sin.minimum()) {
        PRINT_MESSAGE(1000/*???*/, n, "ScaledInteger rawValue is less than declared minimum: " + toString(rawValue), cvp, index);
        return(false);
    }

    /// Is scale illegal?
    if (scale == 0.0) {
        PRINT_MESSAGE(1000/*???*/, n, "ScaledInteger scale is zero", cvp, index);
        return(false);
    }

    /// Check if anything suspicious
    if (rawValue > 1e12 || rawValue < -1e12)
        PRINT_MESSAGE(3000/*???*/, n, "magnitude of ScaledInteger rawValue is suspiciously large: " + toString(rawValue), cvp, index);
    if (fabs(scale) > 1e12)
        PRINT_MESSAGE(3000/*???*/, n, "magnitude of ScaledInteger scale is suspiciously large: " + toString(scale), cvp, index);
    if (fabs(scale) < 1e-12)
        PRINT_MESSAGE(3000/*???*/, n, "ScaledInteger scale is suspiciously close to zero: " + toString(scale), cvp, index);
    if (fabs(offset) > 1e12)
        PRINT_MESSAGE(3000/*???*/, n, "magnitude of ScaledInteger offset is suspiciously large: " + toString(offset), cvp, index);
    if (offset != 0.0 && fabs(offset) < 1e-12)
        PRINT_MESSAGE(3000/*???*/, n, "ScaledInteger offset is suspiciously close to zero: " + toString(offset), cvp, index);
    if (fabs(scaledValue) > 1e12)
        PRINT_MESSAGE(3000/*???*/, n, "magnitude of ScaledInteger scaledValue is suspiciously large: " + toString(scaledValue), cvp, index);
    if (scaledValue != 0 && fabs(scaledValue) < 1e-12)
        PRINT_MESSAGE(3000/*???*/, n, "ScaledInteger scaledValue is suspiciously close to zero: " + toString(scaledValue), cvp, index);

    return(true);
}

bool E57Validator::validateFloat(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (n.type() != E57_FLOAT) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting Float type", cvp, index);
        return(false);
    }

    FloatNode fn = FloatNode(n);
    double value = fn.value();

    /// Check not outside declared bounds
    if (value > fn.maximum()) {
        PRINT_MESSAGE(1000/*???*/, n, "Float is greater than declared maximum: " + toString(value), cvp, index);
        return(false);
    }
    if (value < fn.minimum()) {
        PRINT_MESSAGE(1000/*???*/, n, "Float is less than declared maximum: " + toString(value), cvp, index);
        return(false);
    }

    /// Check if anything suspicious
    if (fabs(value) > 1e12)
        PRINT_MESSAGE(3000/*???*/, n, "magnitude of Float value is suspiciously large: " + toString(value), cvp, index);
    if (value != 0.0 && fabs(value) < 1e-12)
        PRINT_MESSAGE(3000/*???*/, n, "magnitude of Float value is suspiciously close to zero: " + toString(value), cvp, index);

    return(true);
}

bool E57Validator::validateDoubleFloat(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (!validateFloat(n))
        return(false);

    FloatNode fn = FloatNode(n);
	double value = fn.value();		//Added by SC
    if (value != 0.0 && fn.precision() != E57_DOUBLE) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting E57_DOUBLE precision for Float", cvp, index);
        return(false);
    }

    return(true);
}

bool E57Validator::validateNumeric(Node n, bool allowInteger, CompressedVectorNode* cvp, uint64_t index) {
    switch (n.type()) {
        case E57_FLOAT:
            return(validateFloat(n));
        case E57_SCALED_INTEGER:
            return(validateScaledInteger(n));
        case E57_INTEGER:
            if (allowInteger)
                return(validateInteger(n));
            // fall through to default case...
        default:
            if (allowInteger)
                PRINT_MESSAGE(1000/*???*/, n, "expecting Float, ScaledInteger, or Integer types", cvp, index);
            else
                PRINT_MESSAGE(1000/*???*/, n, "expecting Float, or ScaledInteger types", cvp, index);
            return(false);
    }
    return(true);
}

bool E57Validator::validateString(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (n.type() != E57_STRING) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting String type", cvp, index);
        return(false);
    }
    //??? check unicode encoding is correct

    /// Check if anything suspicious
    //??? empty string is suspicious
    //??? only whitespace in string is suspicious
    return(true);
}

bool E57Validator::validateBlob(Node n) {
    if (n.type() != E57_BLOB) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting Blob type", NULL, 0);
        return(false);
    }
    BlobNode bn = BlobNode(n);

    /// Check if anything suspicious
    if (bn.byteCount() < 4)
        PRINT_MESSAGE(3000/*???*/, n, "Blob byte count is suspiciously small: " + toString(bn.byteCount()), NULL, 0);

    return(true);
}

bool E57Validator::validateStructure(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (n.type() != E57_STRUCTURE) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting Structure type", cvp, index);
        return(false);
    }
    return(true);
}

bool E57Validator::validateHomogeneousVector(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (n.type() != E57_VECTOR) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting Vector type", cvp, index);
        return(false);
    }
    VectorNode vn = VectorNode(n);
    if (vn.allowHeteroChildren()) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting homogeneous Vector", cvp, index);
        return(false);
    }
    return(true);
}

bool E57Validator::validateHeterogeneousVector(Node n, CompressedVectorNode* cvp, uint64_t index) {
    if (n.type() != E57_VECTOR) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting Vector type", cvp, index);
        return(false);
    }
    VectorNode vn = VectorNode(n);
    if (!vn.allowHeteroChildren()) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting heterogeneous Vector", cvp, index);
        return(false);
    }
    return(true);
}

bool E57Validator::validateCompressedVector(Node n) {
    if (n.type() != E57_COMPRESSED_VECTOR) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting CompressedVector type", NULL, 0);
        return(false);
    }
    if (!validateCodecs(n))
        return(false);
    return(true);
}

bool E57Validator::validateCodecs(Node n) {
    //???
    return(true);
}

bool E57Validator::validateCodec(CompressedVectorNode cv) {
    VectorNode codecs = cv.codecs();

    /// Validate each child element of codec
    for (int64_t i = 0; i < codecs.childCount(); i++) {
        Node cc = codecs.get(i);

        /// Validate type and downcast
        if (!validateStructure(cc))
            return(false);
        StructureNode sn = StructureNode(cc);

        /// Verify required elements exist
        checkRequired(sn, "inputs"); //???

        /// Validate each child element of Structure
        for (int64_t j = 0; j < sn.childCount(); j++) {
            Node childn = sn.get(j);
            ustring childName = childn.elementName();

            if (childName == "inputs") {
                validateCodecInputs(childn);
            } else if (childName == "bitPackCodec") {
                validateBitPackCodec(childn);
            } else
                PRINT_MESSAGE(1000/*???*/, cv, "???", NULL, 0);
        }
    }

    return(true); //??? need flag?
}

void E57Validator::validateCodecInputs(Node n) {
    //???
}

void E57Validator::validateBitPackCodec(Node n) {
    //???
}

//================================================================

 void E57Validator::validateE57Root(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "formatName");
    checkRequired(sn, "guid");
    checkRequired(sn, "versionMajor");
    checkRequired(sn, "versionMinor");

//??? missing "e57LibraryVersion" is suspicious

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "formatName") {
            if (!validateString(childn))
                continue;
//???
//            if (StringNode(childn).value() != "???")
//                PRINT_MESSAGE(1000/*???*/, childn,"content must be \"???\"");
        } else if (childName == "guid") {
            validateGuid(childn);
        } else if (childName == "versionMajor") {
            if (!validateInteger(childn))
                continue;
            if (IntegerNode(childn).value() != 1)
                PRINT_MESSAGE(1000/*???*/, childn, "value must be 1, found:" + toString(IntegerNode(childn).value()), NULL, 0);
        } else if (childName == "versionMinor") {
            if (!validateInteger(childn))
                continue;
            if (IntegerNode(childn).value() != 0)
                PRINT_MESSAGE(1000/*???*/, childn, "value must be 0, found:" + toString(IntegerNode(childn).value()), NULL, 0);
        } else if (childName == "e57LibraryVersion") {
            if (!validateString(childn))
                continue;
            PRINT_MESSAGE(4000/*???*/, childn, "library version of writer: " + StringNode(childn).value(), NULL, 0);
        } else if (childName == "creationDateTime") {
            validateDateTime(childn);
        } else if (childName == "data3D") {
            validateData3D(childn);
        } else if (childName == "images2D") {
            validateImages2D(childn);
        } else if (childName == "coordinateMetadata") {
            validateCoordinateMetadata(childn);
        } else
            validateExtensionElement(childn);
    }
}

void E57Validator::validateData3D(Node n) {
    /// Validate type and downcast
    if (!validateHeterogeneousVector(n))
        return;
    VectorNode v = VectorNode(n);

    /// Validate each child element of Vector
    for (int64_t i = 0; i < v.childCount(); i++) {
        Node vc = v.get(i);

        /// Validate type and downcast
        if (!validateStructure(vc))
            return;
        StructureNode sn = StructureNode(vc);

        /// Verify required elements exist
        checkRequired(sn, "guid");
        checkRequired(sn, "points");
//        checkRequired(sn, "pose");	//added by SC, not required in standard.

        /// Validate each child element of Structure
        for (int64_t j = 0; j < sn.childCount(); j++) {
            Node childn = sn.get(j);
            ustring childName = childn.elementName();

            if (childName == "guid") {
                validateGuid(childn);
            } else if (childName == "points") {
                validatePoints(childn);
            } else if (childName == "pose") {
                validateRigidBodyTransform(childn);
            } else if (childName == "originalGuids") {
                validateOriginalGuids(childn);
            } else if (childName == "pointGroupingSchemes") {
                validatePointGroupingSchemes(childn);
            } else if (childName == "name") {
                if (!validateString(childn))
                    continue;
            } else if (childName == "description") {
                if (!validateString(childn))
                    continue;
            } else if (childName == "cartesianBounds") {
                validateCartesianBounds(childn);
            } else if (childName == "sphericalBounds") {
                validateSphericalBounds(childn);
            } else if (childName == "indexBounds") {
                validateIndexBounds(childn);
            } else if (childName == "intensityLimits") {	//added by sc
                validateIntensityLimits(childn);
			} else if (childName == "colorLimits") {		//added by sc
                validateColorLimits(childn);
            } else if (childName == "acquisitionStart") {
                validateDateTime(childn);
            } else if (childName == "acquisitionEnd") {
                validateDateTime(childn);
                /// acquisitionStart must be defined
                /// check after start
            } else if (childName == "sensorVendor") {
                if (!validateString(childn))  //??? allow Unicode?
                    continue;
            } else if (childName == "sensorModel") {
                if (!validateString(childn))
                    continue;
            } else if (childName == "sensorSerialNumber") {
                if (!validateString(childn))
                    continue;
            } else if (childName == "sensorHardwareVersion") {
                if (!validateString(childn))
                    continue;
            } else if (childName == "sensorSoftwareVersion") {
                if (!validateString(childn))
                    continue;
            } else if (childName == "sensorFirmwareVersion") {
                if (!validateString(childn))
                    continue;
            } else if (childName == "temperature") {
                if (!validateFloat(childn))
                    continue;
                /// check min???
            } else if (childName == "relativeHumidity") {
                if (!validateFloat(childn))
                    continue;
                /// check min/max???
            } else if (childName == "atmosphericPressure") {
                if (!validateFloat(childn))
                    continue;
                /// check min???
            } else
                validateExtensionElement(childn);
        }
    }
}

void E57Validator::validateOriginalGuids(Node n) {
    //???
}

void E57Validator::validatePoints(Node n) {
    /// Validate type and downcast
    if (!validateCompressedVector(n))
        return;
    CompressedVectorNode cv = CompressedVectorNode(n);

    /// Get prototype, check that it is a Structure and downcast
    if (cv.prototype().type() != E57_STRUCTURE) {
        PRINT_MESSAGE(1000/*???*/, cv, "prototype of this CompressedVector must be a Structure", NULL, 0);
        return;
    }
    StructureNode proto = StructureNode(cv.prototype());

    /// Verify required elements exist
    if (proto.isDefined("cartesianX") || proto.isDefined("cartesianY") || proto.isDefined("cartesianZ")) {
        checkRequired(proto, "cartesianX", &cv);
        checkRequired(proto, "cartesianY", &cv);
        checkRequired(proto, "cartesianZ", &cv);
    } else if (proto.isDefined("sphericalRange") || proto.isDefined("sphericalAzimuth") || proto.isDefined("sphericalElevation")) {
        checkRequired(proto, "sphericalRange", &cv);
        checkRequired(proto, "sphericalAzimuth", &cv);
        checkRequired(proto, "sphericalElevation", &cv);
    } else
        PRINT_MESSAGE(1000/*???*/, proto, "no XYZ or RAE coordinates defined", &cv, 0);

    /// Create struct to hold all dest buffers for fields that are used
    PointBuffers pbufs = PointBuffers();

    /// Validate each child element in prototype
    for (int64_t i = 0; i < proto.childCount(); i++) {
        Node childn = proto.get(i);
        ustring childName = childn.elementName();

        if (childName == "cartesianX") {
            if (!validateNumeric(childn, true, &cv))
                continue;
//??? make sure cartesianBounds defined
            pbufs.cartesianX = new double[pbufs.elementCount];
        } else if (childName == "cartesianY") {
            if (!validateNumeric(childn, true, &cv))
                continue;
            pbufs.cartesianY = new double[pbufs.elementCount];
        } else if (childName == "cartesianZ") {
            if (!validateNumeric(childn, true, &cv))
                continue;
            pbufs.cartesianZ = new double[pbufs.elementCount];
        } else if (childName == "sphericalRange") {
            if (!validateNumeric(childn, true, &cv))
                continue;
//??? make sure sphericalBounds defined
            pbufs.sphericalRange = new double[pbufs.elementCount];
        } else if (childName == "sphericalAzimuth") {
            if (!validateNumeric(childn, false, &cv))
                continue;
            pbufs.sphericalAzimuth = new double[pbufs.elementCount];
        } else if (childName == "sphericalElevation") {
            if (!validateNumeric(childn, false, &cv))
                continue;
            pbufs.sphericalElevation = new double[pbufs.elementCount];
        } else if (childName == "rowIndex") {
            if (!validateInteger(childn, &cv))
                continue;
//??? make sure indexBounds/rowMinimum, rowMaximum defined
            pbufs.rowIndex = new int64_t[pbufs.elementCount];
        } else if (childName == "columnIndex") {
            if (!validateInteger(childn, &cv))
                continue;
//??? make sure indexBounds/columnMinimum, columnMaximum defined
            pbufs.columnIndex = new int64_t[pbufs.elementCount];
        } else if (childName == "returnCount") {
            if (!validateInteger(childn, &cv))
                continue;
//??? check returnIndex defined
//??? make sure indexBounds/returnMinimum, returnMaximum defined
            pbufs.returnCount = new int64_t[pbufs.elementCount];
        } else if (childName == "returnIndex") {
            if (!validateInteger(childn, &cv))
                continue;
//??? check returnCount defined
            pbufs.returnIndex = new int64_t[pbufs.elementCount];
        } else if (childName == "timeStamp") {
            if (!validateNumeric(childn, true, &cv))
                continue;
            pbufs.timeStamp = new double[pbufs.elementCount];
        } else if (childName == "intensity") {
            if (!validateNumeric(childn, true, &cv))
                continue;
            pbufs.intensity = new double[pbufs.elementCount];
        } else if (childName == "colorRed") {
            if (!validateNumeric(childn, true, &cv))
                continue;
//??? make sure colorGreen, colorBlue defined
            pbufs.colorRed = new double[pbufs.elementCount];
        } else if (childName == "colorGreen") {
            if (!validateNumeric(childn, true, &cv))
                continue;
//??? make sure colorRed, colorBlue defined
            pbufs.colorGreen = new double[pbufs.elementCount];
        } else if (childName == "colorBlue") {
            if (!validateNumeric(childn, true, &cv))
                continue;
//??? make sure colorRed, colorGreen defined
            pbufs.colorBlue = new double[pbufs.elementCount];
        } else if (childName == "cartesianInvalidState") {
            if (!validateInteger(childn, &cv))
                continue;
//??? warning cartesian coordinates not defined
            pbufs.cartesianInvalidState = new int8_t[pbufs.elementCount];
        } else if (childName == "sphericalInvalidState") {
            if (!validateInteger(childn, &cv))
                continue;
//??? warning spherical coordinates not defined
            pbufs.sphericalInvalidState = new int8_t[pbufs.elementCount];
        } else if (childName == "isTimeStampInvalid") {
            if (!validateInteger(childn, &cv))
                continue;
//??? warning timeStamp not defined
            pbufs.isTimeStampInvalid = new int8_t[pbufs.elementCount];
        } else if (childName == "isIntensityInvalid") {
            if (!validateInteger(childn, &cv))
                continue;
//??? warning intensity not defined
            pbufs.isIntensityInvalid = new int8_t[pbufs.elementCount];
        } else if (childName == "isColorInvalid") {
            if (!validateInteger(childn, &cv))
                continue;
//??? warning color elements not defined
            pbufs.isColorInvalid = new int8_t[pbufs.elementCount];
        } else
            validateExtensionElement(childn, &cv);
    }

    //??? check contents of CV
    validatePointRecordContents(cv, proto, pbufs);
}

void E57Validator::validatePointRecordContents(CompressedVectorNode cv, StructureNode proto, PointBuffers& pbufs) {
    StructureNode data3D = StructureNode(cv.parent());

    /// Read defined line grouping into memory (if any)
    LineGrouping lineGrouping(cv.parent());
//cout << "lineGrouping:" << endl; //???
//lineGrouping.dump(4); //???

    /// Get cartesianBounds, if any
    bool cartesianBoundsDefined = false;
    BoundingBox cartesianBounds;
    if (data3D.isDefined("cartesianBounds")) {
        cartesianBoundsDefined = true;
        cartesianBounds = BoundingBox(StructureNode(data3D.get("cartesianBounds")), "cartesianBounds");
//cout << "cartesianBounds:" << endl; //???
//cartesianBounds.dump(4); //???
    }

    /// Get sphericalBounds, if any
    bool sphericalBoundsDefined = false;
    BoundingBox sphericalBounds;
    if (data3D.isDefined("sphericalBounds")) {
        sphericalBoundsDefined = true;
        sphericalBounds = BoundingBox(StructureNode(data3D.get("sphericalBounds")), "sphericalBounds");
//cout << "sphericalBounds:" << endl; //???
//sphericalBounds.dump(4); //???
    }

    /// Get indexBounds, if any
    bool indexBoundsDefined = false;
    BoundingBox indexBounds;
    if (data3D.isDefined("indexBounds")) {
        indexBoundsDefined = true;
        indexBounds = BoundingBox(StructureNode(data3D.get("indexBounds")), "indexBounds");
//cout << "indexBounds:" << endl; //???
//indexBounds.dump(4); //???
    }

    /// Declare bounding boxes for actual points
    BoundingBox scanCartesianBoundsActual;
    BoundingBox scanSphericalBoundsActual;

    int64_t rowIndexActualMinimum    = E57_INT64_MAX;
    int64_t rowIndexActualMaximum    = E57_INT64_MIN;
    int64_t columnIndexActualMinimum = E57_INT64_MAX;
    int64_t columnIndexActualMaximum = E57_INT64_MIN;
    int64_t returnIndexActualMinimum = E57_INT64_MAX;
    int64_t returnIndexActualMaximum = E57_INT64_MIN;

    int64_t prevReturnIndex = 0;
    int64_t prevReturnCount = 0;

    /// Get iterator that reads CompressedVector contents in blocks
    CompressedVectorReader reader = cv.reader(pbufs.allBuffers(cv.destImageFile()));

    size_t gotCount = 0;
    uint64_t blockStart = 0;
    do {
        /// Read a block of data into the buffers in pbufs
        gotCount = reader.read();
//printf("points read, gotCount=%d\n", gotCount); //???

        /// Process block one record at a time
        for (size_t i = 0; i < gotCount; i++) {
            //================================================================
            if (pbufs.cartesianX && pbufs.cartesianY && pbufs.cartesianZ) {
                if (!pbufs.cartesianInvalidState || pbufs.cartesianInvalidState[i] == 0) {  /// This point coordinate is valid
                    /// Calc spherical coords from cartesian using formulas from 5.5 of ASTM E57 standard
                    double range = sqrt(pbufs.cartesianX[i]*pbufs.cartesianX[i]
                                        + pbufs.cartesianY[i]*pbufs.cartesianY[i]
                                        + pbufs.cartesianZ[i]*pbufs.cartesianZ[i]);
                    double azimuth = 0.0;
                    if (pbufs.cartesianX[i] != 0 || pbufs.cartesianY[i] != 0)
                        azimuth = atan2(pbufs.cartesianY[i], pbufs.cartesianX[i]);
                    double elevation = 0.0;
                    if (range != 0)
                        elevation = asin(pbufs.cartesianZ[i] / range);

                    /// Check each coordinate in Cartesian bounds
                    if (cartesianBoundsDefined && cartesianBounds.notEmpty) {
                        if ((pbufs.cartesianX[i] < cartesianBounds.minimum[0]) || (cartesianBounds.maximum[0] < pbufs.cartesianX[i]))
                            PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"), "value " + toString(pbufs.cartesianX[i]) + " is out of Cartesian bounds", &cv, blockStart+i);
                        if ((pbufs.cartesianY[i] < cartesianBounds.minimum[1]) || (cartesianBounds.maximum[1] < pbufs.cartesianY[i]))
                            PRINT_MESSAGE(1000/*???*/, proto.get("cartesianY"), "value " + toString(pbufs.cartesianY[i]) + " is out of Cartesian bounds", &cv, blockStart+i);
                        if ((pbufs.cartesianZ[i] < cartesianBounds.minimum[2]) || (cartesianBounds.maximum[2] < pbufs.cartesianZ[i]))
                            PRINT_MESSAGE(1000/*???*/, proto.get("cartesianZ"), "value " + toString(pbufs.cartesianZ[i]) + " is out of Cartesian bounds", &cv, blockStart+i);
                    }

                    /// Check each coordinate in Spherical bounds
                    if (sphericalBoundsDefined && sphericalBounds.notEmpty) {
                        if ((range < sphericalBounds.minimum[0]) || (sphericalBounds.maximum[0] < range))
                            PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"), "converted range " + toString(range) + " is out of spherical bounds", &cv, blockStart+i);
                        if ((azimuth < sphericalBounds.minimum[1]) || (sphericalBounds.maximum[1] < azimuth))
                            PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"), "converted azimuth " + toString(azimuth) + " is out of spherical bounds", &cv, blockStart+i);
                        if ((elevation < sphericalBounds.minimum[2]) || (sphericalBounds.maximum[2] < elevation))
                            PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"), "converted elevation " + toString(elevation) + " is out of spherical bounds", &cv, blockStart+i);
                    }

                    /// Get lineIndex from row or column
                    bool usesLineGroups = lineGrouping.isDefined();
                    int64_t lineIndex;
                    if (usesLineGroups) {
                        if (lineGrouping.isByRow()) {
                            if (pbufs.rowIndex)
                                lineIndex = pbufs.rowIndex[i];
                            else
                                usesLineGroups = false;
                        } else {
                            if (pbufs.columnIndex)
                                lineIndex = pbufs.columnIndex[i];
                            else
                                usesLineGroups = false;
                        }
                    }

                    /// Get group and test matches this point
                    if (usesLineGroups) {
                        LineGroup* lineGroup = lineGrouping.findLineGroup(lineIndex);
                        if (lineGroup) {
                            /// Check is inside cartesian bounding box of the lineGroup
                            if (lineGroup->declaredCartesianBoundsDefined) {
//lineGroup->declaredCartesianBounds.dump(4); //???
                                if (pbufs.cartesianX[i] < lineGroup->declaredCartesianBounds.minimum[0]
                                    || lineGroup->declaredCartesianBounds.maximum[0] < pbufs.cartesianX[i]) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"),
                                               "value " + toString(pbufs.cartesianX[i]) + " is out of Cartesian bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (pbufs.cartesianY[i] < lineGroup->declaredCartesianBounds.minimum[1]
                                    || lineGroup->declaredCartesianBounds.maximum[1] < pbufs.cartesianY[i]) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("cartesianY"),
                                               "value " + toString(pbufs.cartesianY[i]) + " is out of Cartesian bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (pbufs.cartesianZ[i] < lineGroup->declaredCartesianBounds.minimum[2]
                                    || lineGroup->declaredCartesianBounds.maximum[2] < pbufs.cartesianZ[i]) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("cartesianZ"),
                                               "value " + toString(pbufs.cartesianZ[i]) + " is out of Cartesian bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                            }

                            /// Check is inside spherical bounding box of the lineGroup
                            if (lineGroup->declaredSphericalBoundsDefined) {
                                if (range < lineGroup->declaredSphericalBounds.minimum[0]
                                    || lineGroup->declaredSphericalBounds.maximum[0] < range) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"),
                                               "converted range " + toString(range) + " is out of Spherical bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (azimuth < lineGroup->declaredSphericalBounds.minimum[1]
                                    || lineGroup->declaredSphericalBounds.maximum[1] < azimuth) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"),
                                               "converted azimuth " + toString(azimuth) + " is out of Spherical bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (elevation < lineGroup->declaredSphericalBounds.minimum[2]
                                    || lineGroup->declaredSphericalBounds.maximum[2] < elevation) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("cartesianX"),
                                               "converted elevation " + toString(elevation) + " is out of Spherical bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                            }

                            /// Add point to lineGroup actual bounding boxes
                            lineGroup->actualCartesianBounds.addPoint(pbufs.cartesianX[i], pbufs.cartesianY[i], pbufs.cartesianZ[i]);
                            lineGroup->actualSphericalBounds.addPoint(range, azimuth, elevation);
                        } else {
                            if (lineGrouping.isByRow())
                                PRINT_MESSAGE(1000/*???*/, proto.get("rowIndex"), "no line group for row number " + toString(lineIndex), &cv, blockStart+i);
                            else
                                PRINT_MESSAGE(1000/*???*/, proto.get("columnIndex"), "no line group for column number " + toString(lineIndex), &cv, blockStart+i);
                        }
                    }

                    /// Add point to scan bounding box
                    scanCartesianBoundsActual.addPoint(pbufs.cartesianX[i], pbufs.cartesianY[i], pbufs.cartesianZ[i]);
                    scanSphericalBoundsActual.addPoint(range, azimuth, elevation);
//??? update actual count, actual start

                } else if (pbufs.cartesianInvalidState[i] == 1) {
                    /// Only direction vector of this point coordinate is valid
                    double range = sqrt(pbufs.cartesianX[i]*pbufs.cartesianX[i]
                                        + pbufs.cartesianY[i]*pbufs.cartesianY[i]
                                        + pbufs.cartesianZ[i]*pbufs.cartesianZ[i]);
                    /// Suspicious if magnitude is zero
                    if (range == 0) //??? warning?
                       PRINT_MESSAGE(3000/*???*/, proto.get("cartesianX"), "only point direction is meaningful, but magnitude is zero", &cv, blockStart+i);
                } else if (pbufs.cartesianInvalidState[i] == 2) {
                    /// This point coordinate has no meaningful values
                    /// Nothing to check
                } else
                   PRINT_MESSAGE(1000/*???*/, proto.get("cartesianInvalidState"), "illegal value", &cv, blockStart+i);
            }

            //================================================================
            if (pbufs.sphericalRange && pbufs.sphericalAzimuth && pbufs.sphericalElevation) {
                if (!pbufs.sphericalInvalidState || pbufs.sphericalInvalidState[i] == 0) {  /// This point coordinate is valid
                    /// Calc cartesian coords from spherical using formulas from 5.5 of ASTM E57 standard
                    double x = pbufs.sphericalRange[i] * cos(pbufs.sphericalElevation[i]) * cos(pbufs.sphericalAzimuth[i]);
                    double y = pbufs.sphericalRange[i] * cos(pbufs.sphericalElevation[i]) * sin(pbufs.sphericalAzimuth[i]);
                    double z = pbufs.sphericalRange[i] * sin(pbufs.sphericalElevation[i]);

                    /// Check each coordinate in Spherical bounds
                    if (sphericalBoundsDefined && sphericalBounds.notEmpty) {
                        if (pbufs.sphericalRange[i] < sphericalBounds.minimum[0] || sphericalBounds.maximum[0] < pbufs.sphericalRange[i])
                            PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"), "value " + toString(pbufs.sphericalRange[i]) + " is out of spherical bounds", &cv, blockStart+i);
                        if (pbufs.sphericalAzimuth[i] < sphericalBounds.minimum[1] || sphericalBounds.maximum[1] < pbufs.sphericalAzimuth[i])
                            PRINT_MESSAGE(1000/*???*/, proto.get("sphericalAzimuth"), "value " + toString(pbufs.sphericalAzimuth[i]) + " is out of spherical bounds", &cv, blockStart+i);
                        if (pbufs.sphericalElevation[i] < sphericalBounds.minimum[2] || sphericalBounds.maximum[2] < pbufs.sphericalElevation[i])
                            PRINT_MESSAGE(1000/*???*/, proto.get("sphericalElevation"), "value " + toString(pbufs.sphericalElevation[i]) + " is out of spherical bounds", &cv, blockStart+i);
                    }

                    /// Check each coordinate in Cartesian bounds
                    if (cartesianBoundsDefined && cartesianBounds.notEmpty) {
                        if (x < cartesianBounds.minimum[0] || cartesianBounds.maximum[0] < x)
                            PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"), "converted x " + toString(x) + " is out of Cartesian bounds", &cv, blockStart+i);
                        if (y < cartesianBounds.minimum[1] || cartesianBounds.maximum[1] < y)
                            PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"), "converted y " + toString(y) + " is out of Cartesian bounds", &cv, blockStart+i);
                        if (z < cartesianBounds.minimum[2] || cartesianBounds.maximum[2] < z)
                            PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"), "converted z " + toString(z) + " is out of Cartesian bounds", &cv, blockStart+i);
                    }

                    /// Get lineIndex from row or column
                    bool usesLineGroups = lineGrouping.isDefined();
                    int64_t lineIndex;
                    if (usesLineGroups) {
                        if (lineGrouping.isByRow()) {
                            if (pbufs.rowIndex)
                                lineIndex = pbufs.rowIndex[i];
                            else
                                usesLineGroups = false;
                        } else {
                            if (pbufs.columnIndex)
                                lineIndex = pbufs.columnIndex[i];
                            else
                                usesLineGroups = false;
                        }
                    }

                    /// Get group and test matches this point
                    if (usesLineGroups) {
                        LineGroup* lineGroup = lineGrouping.findLineGroup(lineIndex);
                        if (lineGroup) {
                            /// Check is inside spherical bounding box of the lineGroup
                            if (lineGroup->declaredSphericalBoundsDefined) {
                                if (pbufs.sphericalRange[i] < lineGroup->declaredSphericalBounds.minimum[0]
                                    || lineGroup->declaredSphericalBounds.maximum[0] < pbufs.sphericalRange[i]) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"),
                                               "value " + toString(pbufs.sphericalRange[i]) + " is out of Spherical bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (pbufs.sphericalAzimuth[i] < lineGroup->declaredSphericalBounds.minimum[1]
                                    || lineGroup->declaredSphericalBounds.maximum[1] < pbufs.sphericalAzimuth[i]) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("sphericalAzimuth"),
                                               "value " + toString(pbufs.sphericalAzimuth[i]) + " is out of Spherical bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (pbufs.sphericalElevation[i] < lineGroup->declaredSphericalBounds.minimum[2]
                                    || lineGroup->declaredSphericalBounds.maximum[2] < pbufs.sphericalElevation[i]) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("sphericalElevation"),
                                               "value " + toString(pbufs.sphericalElevation[i]) + " is out of Spherical bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                            }

                            /// Check is inside Cartesian bounding box of the lineGroup
                            if (lineGroup->declaredCartesianBoundsDefined) {
                                if (x < lineGroup->declaredCartesianBounds.minimum[0]
                                    || lineGroup->declaredCartesianBounds.maximum[0] < x) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"),
                                               "converted x " + toString(x) + " is out of Cartesian bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (y < lineGroup->declaredCartesianBounds.minimum[1]
                                    || lineGroup->declaredCartesianBounds.maximum[1] < y) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"),
                                               "converted y " + toString(y) + " is out of Cartesian bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                                if (z < lineGroup->declaredCartesianBounds.minimum[2]
                                    || lineGroup->declaredCartesianBounds.maximum[2] < z) {
                                    PRINT_MESSAGE(1000/*???*/, proto.get("sphericalRange"),
                                               "converted z " + toString(z) + " is out of Cartesian bounds of line group "
                                               + toString(lineIndex),
                                               &cv, blockStart+i);
                                }
                            }

                            /// Add point to lineGroup actual bounding boxes
                            lineGroup->actualSphericalBounds.addPoint(pbufs.sphericalRange[i], pbufs.sphericalAzimuth[i], pbufs.sphericalElevation[i]);
                            lineGroup->actualCartesianBounds.addPoint(x, y, z);

//??? increment actual count

                        } else {
                            if (lineGrouping.isByRow())
                                PRINT_MESSAGE(1000/*???*/, proto.get("rowIndex"), "no line group for row number " + toString(lineIndex), &cv, blockStart+i);
                            else
                                PRINT_MESSAGE(1000/*???*/, proto.get("columnIndex"), "no line group for column number " + toString(lineIndex), &cv, blockStart+i);
                        }
                    }

                    /// Add point to scan bounding box
                    scanSphericalBoundsActual.addPoint(pbufs.sphericalRange[i], pbufs.sphericalAzimuth[i], pbufs.sphericalElevation[i]);
                    scanCartesianBoundsActual.addPoint(x, y, z);
                } else if (pbufs.sphericalInvalidState[i] == 1) {
                    /// Range coordinate has no meaningful value
                    /// Nothing to check
                } else if (pbufs.sphericalInvalidState[i] == 2) {
                    /// All three coordinates have no meaningful values
                    /// Nothing to check
                } else
                   PRINT_MESSAGE(1000/*???*/, proto.get("sphericalInvalidState"), "illegal value", &cv, blockStart+i);
            }

            //================================================================
            if (pbufs.rowIndex) {
                /// Check within declared scanIndexBounds
                if (pbufs.rowIndex[i] < indexBounds.minimum[0] || indexBounds.maximum[0] < pbufs.rowIndex[i]) {
                    PRINT_MESSAGE(1000/*???*/, proto.get("rowIndex"),
                               "value " + toString(pbufs.rowIndex[i]) + " is out of indexBounds ["
                               + toString(indexBounds.minimum[0]) + "," + toString(indexBounds.maximum[0]) + "]",
                               &cv, blockStart+i);
                }

//??? susp large, 10^12

                /// Update min/max of rowIndex
                if (pbufs.rowIndex[i] < rowIndexActualMinimum)
                    rowIndexActualMinimum = pbufs.rowIndex[i];
                if (pbufs.rowIndex[i] > rowIndexActualMaximum)
                    rowIndexActualMaximum = pbufs.rowIndex[i];
            }

            //================================================================
            if (pbufs.columnIndex) {
                /// Check within declared scanIndexBounds
                if (pbufs.columnIndex[i] < indexBounds.minimum[1] || indexBounds.maximum[1] < pbufs.columnIndex[i]) {
                    PRINT_MESSAGE(1000/*???*/, proto.get("columnIndex"),
                               "value " + toString(pbufs.columnIndex[i]) + " is out of indexBounds ["
                               + toString(indexBounds.minimum[1]) + "," + toString(indexBounds.maximum[1]) + "]",
                               &cv, blockStart+i);
                }

//??? susp large,
//??? no (row,col) repeats?

                /// Update min/max of columnIndex
                if (pbufs.columnIndex[i] < columnIndexActualMinimum)
                    columnIndexActualMinimum = pbufs.columnIndex[i];
                if (pbufs.columnIndex[i] > columnIndexActualMaximum)
                    columnIndexActualMaximum = pbufs.columnIndex[i];
            }

            //================================================================
            if (pbufs.returnCount) {
//??? positive, same for each (row,col), (row,column) contiguous, but not necc sorted
            }

            //================================================================
            if (pbufs.returnIndex && pbufs.returnCount) {
                /// Check returnIndex is in [0,returnCount)
                if (pbufs.returnIndex[i] < 0) {
                    PRINT_MESSAGE(1000/*???*/, proto.get("returnIndex"),
                               "value " + toString(pbufs.returnIndex[i]) + " is negative",
                               &cv, blockStart+i);
                }
                if (pbufs.returnCount[i] <= pbufs.returnIndex[i]) {
                    PRINT_MESSAGE(1000/*???*/, proto.get("returnIndex"),
                               "value " + toString(pbufs.returnIndex[i]) + " is >= returnCount " + toString(pbufs.returnCount[i]),
                               &cv, blockStart+i);
                }

                /// Check within declared indexBounds
                if (pbufs.returnIndex[i] < indexBounds.minimum[2] || indexBounds.maximum[2] < pbufs.returnIndex[i]) {
                    PRINT_MESSAGE(1000/*???*/, proto.get("returnIndex"),
                               "value " + toString(pbufs.returnIndex[i]) + " is out of indexBounds ["
                               + toString(indexBounds.minimum[2]) + "," + toString(indexBounds.maximum[2]) + "]",
                               &cv, blockStart+i);
                }

                /// First point in multiple return sequence must have returnIndex==0
                if (blockStart+i == 0 || prevReturnIndex == prevReturnCount-1) {
                    if (pbufs.returnIndex[i] != 0) {
                        PRINT_MESSAGE(1000/*???*/, proto.get("returnIndex"),
                                   "returnIndex " + toString(pbufs.returnIndex[i]) + " of first point in multiple return sequence not zero",
                                   &cv, blockStart+i);
                    }
                } else {
                    /// Point is not first in multiple return sequence

                    /// Check returnCount is same as previous point in sequence
                    if (pbufs.returnCount[i] != prevReturnCount) {
                        PRINT_MESSAGE(1000/*???*/, proto.get("returnCount"),
                                   "returnCount " + toString(pbufs.returnCount[i]) + " changed within a multiple return sequence",
                                   &cv, blockStart+i);
                    } else {
                        /// Check returnIndex is incremented from previous point
                        if (pbufs.returnIndex[i] != prevReturnIndex+1) {
                            PRINT_MESSAGE(1000/*???*/, proto.get("returnIndex"),
                                       "returnIndex " + toString(pbufs.returnIndex[i]) + " is not incrementing by one",
                                       &cv, blockStart+i);
                        } else {
                            //??? Check that last point in scan ends correctly
                        }
                    }
                }
                prevReturnIndex = pbufs.returnIndex[i];
                prevReturnCount = pbufs.returnCount[i];

//??? warn mult returns not in same direction (with tolerance)

                /// Update min/max of returnIndex
                if (pbufs.returnIndex[i] < returnIndexActualMinimum)
                    returnIndexActualMinimum = pbufs.returnIndex[i];
                if (pbufs.returnIndex[i] > returnIndexActualMaximum)
                    returnIndexActualMaximum = pbufs.returnIndex[i];
            }

            //================================================================
            if (pbufs.timeStamp) {
                if (pbufs.isTimeStampInvalid && pbufs.isTimeStampInvalid[i]) {
                    /// timeStamp not meaningful, warn if not set to minimum ???
                } else {
                    //??? check timeStamp not negative, too large  vs. acquistionEnd
                }
            }

            //================================================================
            if (pbufs.intensity) {
                if (pbufs.isIntensityInvalid && pbufs.isIntensityInvalid[i]) {
                    /// Intensity not meaningful, warn if not set to minimum ???
                } else {
                    /// Nothing to check
                }
            }

            //================================================================
            if (pbufs.colorRed && pbufs.colorGreen && pbufs.colorBlue) {
                if (pbufs.isColorInvalid && pbufs.isColorInvalid[i]) {
                    /// Colors not meaningful, warn if not set to minimum ???
                } else {
                    /// Nothing to check
                }
            }
        } // for i

        blockStart += gotCount;
    } while (gotCount > 0);
    reader.close();

    /// Check scan bboxes tight
//???



    //??? check each lineGroup: (actual vs. declared) start, count, bboxes tight
}

//================================================================

void E57Validator::validatePointGroupingSchemes(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    // no elements required

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "groupingByLine") {
            validateGroupingByLine(childn);
        } else
            validateExtensionElement(childn);
    }
}

void E57Validator::validateGroupingByLine(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "idElementName");
    checkRequired(sn, "groups");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "idElementName") {
            if (!validateString(childn))  //??? allow Unicode?
                continue;
            //??? required content
        } else if (childName == "groups") {
            validateLineGroupRecords(childn);
        } else  /// recommend other groupings follow example?
            validateExtensionElement(childn);
    }
}

void E57Validator::validateLineGroupRecords(Node n) {
    /// Validate type and downcast
    if (!validateCompressedVector(n))
        return;
    CompressedVectorNode cv = CompressedVectorNode(n);

    /// Get prototype, check that it is a Structure and downcast
    Node proto = cv.prototype();
    if (proto.type() != E57_STRUCTURE) {
        PRINT_MESSAGE(1000/*???*/, cv, "prototype of this CompressedVector must be a Structure", NULL, 0);
        return;
    }
    StructureNode sn = StructureNode(proto);

    /// Verify required elements exist
    checkRequired(sn, "idElementValue", &cv);

    /// Validate each child element in prototype
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "idElementValue") {
            if (!validateInteger(childn, &cv))
                continue;
        } else if (childName == "startPointIndex") {
            if (!validateInteger(childn, &cv))
                continue;
        } else if (childName == "pointCount") {
            if (!validateInteger(childn, &cv))
                continue;
        } else if (childName == "cartesianBounds") {
            validateCartesianBounds(childn, &cv);
        } else if (childName == "sphericalBounds") {
            validateSphericalBounds(childn, &cv);
        } else  /// recommend other groupings follow example???
            validateExtensionElement(childn, &cv);
    }

    //??? check contents of CV
}

//================================================================

void E57Validator::validateRigidBodyTransform(Node n, CompressedVectorNode* cvp, uint64_t index) {
    /// Validate type and downcast
    if (!validateStructure(n, cvp, index))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "rotation");
    checkRequired(sn, "translation");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "rotation") {
            validateQuaternion(childn);
        } else if (childName == "translation") {
            validateTranslation(childn);
        } else
            validateExtensionElement(childn);
    }
}

void E57Validator::validateQuaternion(Node n, CompressedVectorNode* cvp, uint64_t index) {
    /// Validate type and downcast
    if (!validateStructure(n, cvp, index))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "w");
    checkRequired(sn, "x");
    checkRequired(sn, "y");
    checkRequired(sn, "z");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "w") {
            validateDoubleFloat(childn);
        } else if (childName == "x") {
            validateDoubleFloat(childn);
        } else if (childName == "y") {
            validateDoubleFloat(childn);
        } else if (childName == "z") {
            validateDoubleFloat(childn);
        } else
            validateExtensionElement(childn);
    }

    /// Check quaternion norm is within [1-10*ulp, 1+10*ulp]
    if (sn.isDefined("w") && sn.isDefined("x") && sn.isDefined("y") && sn.isDefined("z")) {
        double w = FloatNode(sn.get("w")).value();
        double x = FloatNode(sn.get("x")).value();
        double y = FloatNode(sn.get("y")).value();
        double z = FloatNode(sn.get("z")).value();
        double norm = sqrt(w*w + x*x + y*y + z*z);
        double ulp = 1.110223024625157e-016; // 2^-53
        if (norm < 1-10*ulp || 1+10*ulp < norm)
            PRINT_MESSAGE(1000/*???*/, n, "norm of quaternion is not close enough to 1.0", cvp, index);
    }
}

void E57Validator::validateTranslation(Node n, CompressedVectorNode* cvp, uint64_t index) {
    /// Validate type and downcast
    if (!validateStructure(n, cvp, index))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "x");
    checkRequired(sn, "y");
    checkRequired(sn, "z");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "x") {
            validateDoubleFloat(childn);
        } else if (childName == "y") {
            validateDoubleFloat(childn);
        } else if (childName == "z") {
            validateDoubleFloat(childn);
        } else
            validateExtensionElement(childn);
    }
}

//================================================================

void E57Validator::validateImages2D(Node n) {
    /// Validate type and downcast
    if (!validateHeterogeneousVector(n))
        return;
    VectorNode v = VectorNode(n);

    /// Validate each child element of Vector
    for (int64_t i = 0; i < v.childCount(); i++) {
        Node vc = v.get(i);

        /// Validate type and downcast
        if (!validateStructure(vc))
            return;
        StructureNode sn = StructureNode(vc);

        /// Verify required elements exist
        checkRequired(sn, "guid");

		if( sn.isDefined("pinholeRepresentation") ||
			sn.isDefined("sphericalRepresentation") ||
			sn.isDefined("cylindricalRepresentation"))
			checkRequired(sn,"pose");

        /// Validate each child element of Structure
        for (int64_t j = 0; j < sn.childCount(); j++) {
            Node childn = sn.get(j);
            ustring childName = childn.elementName();

            if (childName == "guid") {
                validateGuid(childn);
            } else if (childName == "visualReferenceRepresentation") {
                validateVisualReferenceRepresentation(childn);
            } else if (childName == "pinholeRepresentation") {
                validatePinholeRepresentation(childn);
            } else if (childName == "sphericalRepresentation") {
                validateSphericalRepresentation(childn);
            } else if (childName == "cylindricalRepresentation") {
                validateCylindricalRepresentation(childn);
            } else if (childName == "pose") {
                validateRigidBodyTransform(childn);
            } else if (childName == "associatedData3DGuid") {
                validateGuid(childn);
            } else if (childName == "name") {
                validateString(childn);
            } else if (childName == "description") {
                validateString(childn);
            } else if (childName == "acquisitionDateTime") {
                validateDateTime(childn);
            } else if (childName == "sensorVendor") {
                validateString(childn);
            } else if (childName == "sensorModel") {
                validateString(childn);
            } else if (childName == "sensorSerialNumber") {
                validateString(childn);
            } else
                validateExtensionElement(childn);
        }
    }
}

void E57Validator::validateVisualReferenceRepresentation(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "imageWidth");
    checkRequired(sn, "imageHeight");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "jpegImage") {
            validateBlob(childn);
        } else if (childName == "pngImage") {
            validateBlob(childn);
        } else if (childName == "imageMask") {
            validateBlob(childn);
            ///??? match with blob
        } else if (childName == "imageWidth") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else if (childName == "imageHeight") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else
            validateExtensionElement(childn);
    }
}

void E57Validator::validatePinholeRepresentation(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "imageWidth");
    checkRequired(sn, "imageHeight");
    checkRequired(sn, "focalLength");
    checkRequired(sn, "pixelWidth");
    checkRequired(sn, "pixelHeight");
    checkRequired(sn, "principalPointX");
    checkRequired(sn, "principalPointY");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "jpegImage") {
            validateBlob(childn);
        } else if (childName == "pngImage") {
            validateBlob(childn);
        } else if (childName == "imageMask") {
            validateBlob(childn);
            ///??? match with blob
        } else if (childName == "imageWidth") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else if (childName == "imageHeight") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else if (childName == "focalLength") {
            if (!validateFloat(childn))
                continue;
        } else if (childName == "pixelWidth") {
            if (!validateFloat(childn))
                continue;
        } else if (childName == "pixelHeight") {
            if (!validateFloat(childn))
                continue;
        } else if (childName == "principalPointX") {
            if (!validateFloat(childn))
                continue;
            //??? check bounds, > width suspicious
        } else if (childName == "principalPointY") {
            if (!validateFloat(childn))
                continue;
            //??? check bounds, > height suspicious
        } else
            validateExtensionElement(childn);
    }
}

void E57Validator::validateSphericalRepresentation(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "imageWidth");
    checkRequired(sn, "imageHeight");
    checkRequired(sn, "pixelWidth");
    checkRequired(sn, "pixelHeight");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "jpegImage") {
            validateBlob(childn);
        } else if (childName == "pngImage") {
            validateBlob(childn);
        } else if (childName == "imageMask") {
            validateBlob(childn);
            ///??? match with blob
        } else if (childName == "imageWidth") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else if (childName == "imageHeight") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else if (childName == "pixelWidth") {
            if (!validateFloat(childn))
                continue;
        } else if (childName == "pixelHeight") {
            if (!validateFloat(childn))
                continue;
        } else
            validateExtensionElement(childn);
    }
}

void E57Validator::validateCylindricalRepresentation(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "imageWidth");
    checkRequired(sn, "imageHeight");
    checkRequired(sn, "radius");
    checkRequired(sn, "principalPointY");
    checkRequired(sn, "pixelWidth");
    checkRequired(sn, "pixelHeight");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "jpegImage") {
            validateBlob(childn);
        } else if (childName == "pngImage") {
            validateBlob(childn);
        } else if (childName == "imageMask") {
            validateBlob(childn);
            ///??? match with blob
        } else if (childName == "imageWidth") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else if (childName == "imageHeight") {
            if (!validateInteger(childn))
                continue;
            ///??? check bounds
            ///??? match with blob
        } else if (childName == "radius") {
            if (!validateFloat(childn))
                continue;
        } else if (childName == "principalPointY") {
            if (!validateFloat(childn))
                continue;
            //??? check bounds, > height suspicious
        } else if (childName == "pixelWidth") {
            if (!validateFloat(childn))
                continue;
        } else if (childName == "pixelHeight") {
            if (!validateFloat(childn))
                continue;
        } else
            validateExtensionElement(childn);
    }
}

//================================================================

void E57Validator::validateCartesianBounds(Node n, CompressedVectorNode* cvp, uint64_t index) {
    /// Validate type and downcast
    if (!validateStructure(n, cvp, index))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "xMinimum", cvp, index);
    checkRequired(sn, "xMaximum", cvp, index);
    checkRequired(sn, "yMinimum", cvp, index);
    checkRequired(sn, "yMaximum", cvp, index);
    checkRequired(sn, "zMinimum", cvp, index);
    checkRequired(sn, "zMaximum", cvp, index);

    //??? check XYZ used in points

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "xMinimum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "xMaximum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "yMinimum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "yMaximum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "zMinimum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "zMaximum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else
            validateExtensionElement(childn, cvp, index);
    }
}

void E57Validator::validateSphericalBounds(Node n, CompressedVectorNode* cvp, uint64_t index) {
    /// Validate type and downcast
    if (!validateStructure(n, cvp, index))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "rangeMinimum", cvp, index);
    checkRequired(sn, "rangeMaximum", cvp, index);
    checkRequired(sn, "elevationMinimum", cvp, index);
    checkRequired(sn, "elevationMaximum", cvp, index);

    //??? check RAE used in points

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "rangeMinimum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "rangeMaximum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "elevationMinimum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "elevationMaximum") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "azimuthStart") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else if (childName == "azimuthEnd") {
            if (!validateFloat(childn, cvp, index))
                continue;
            //??? check bounds
        } else
            validateExtensionElement(childn, cvp, index);
    }
}

void E57Validator::validateIndexBounds(Node n) {
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    // no required elements
    //??? check row used in points

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "rowMinimum") {
            if (!validateInteger(childn))
                continue;
            //??? check bounds
            //??? check row used in points
            //??? check rowMaximum also defined
        } else if (childName == "rowMaximum") {
            if (!validateInteger(childn))
                continue;
            //??? check bounds
            //??? check row used in points
            //??? check rowMinimum also defined
        } else if (childName == "columnMinimum") {
            if (!validateInteger(childn))
                continue;
            //??? check bounds
            //??? check row used in points
            //??? check columnMaximum also defined
        } else if (childName == "columnMaximum") {
            if (!validateInteger(childn))
                continue;
            //??? check bounds
            //??? check row used in points
            //??? check columnMinimum also defined
        } else if (childName == "returnMinimum") {
            if (!validateInteger(childn))
                continue;
            //??? check bounds
            //??? check row used in points
            //??? check returnMaximum also defined
        } else if (childName == "returnMaximum") {
            if (!validateInteger(childn))
                continue;
            //??? check bounds
            //??? check row used in points
            //??? check returnMinimum also defined
        } else
            validateExtensionElement(childn);
    }
}
void E57Validator::validateIntensityLimits(Node n) {	//added by sc
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    // no required elements
    //??? check row used in points

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "intensityMinimum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check intensity used in points
            //??? check intensityMaximum also defined
        } else if (childName == "intensityMaximum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check intensity used in points
            //??? check intensityMinimum also defined
        } else
            validateExtensionElement(childn);
    }
}
void E57Validator::validateColorLimits(Node n) {	//added by sc
    /// Validate type and downcast
    if (!validateStructure(n))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    // no required elements
    //??? check row used in points

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "colorRedMinimum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check colorRed used in points
            //??? check colorRedMaximum also defined
        } else if (childName == "colorRedMaximum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check colorRed used in points
            //??? check colorRedMinimum also defined
		} else if (childName == "colorGreenMinimum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check colorGreen used in points
            //??? check colorGreenMaximum also defined
        } else if (childName == "colorGreenMaximum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check colorGreen used in points
            //??? check colorGreenMinimum also defined
		} else if (childName == "colorBlueMinimum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check colorBlue used in points
            //??? check colorBlueMaximum also defined
        } else if (childName == "colorBlueMaximum") {
            if (!validateNumeric(childn, true))
                continue;
            //??? check bounds
            //??? check colorBlue used in points
            //??? check colorBlueMinimum also defined
        } else
            validateExtensionElement(childn);
    }
}
//================================================================

void E57Validator::validateDateTime(Node n, CompressedVectorNode* cvp, uint64_t index) {
    /// Validate type and downcast
    if (!validateStructure(n, cvp, index))
        return;
    StructureNode sn = StructureNode(n);

    /// Verify required elements exist
    checkRequired(sn, "dateTimeValue");

    /// Validate each child element
    for (int64_t i = 0; i < sn.childCount(); i++) {
        Node childn = sn.get(i);
        ustring childName = childn.elementName();

        if (childName == "dateTimeValue") {
            if (!validateFloat(childn))
                continue;
            //??? check bounds
            //??? in future is suspicious
            //??? to far in past is suspicious
        } else if (childName == "isAtomicClockReferenced") {
            if (!validateInteger(childn))
                continue;
            //??? check bounds
        } else
            validateExtensionElement(childn);
    }
}

void E57Validator::validateGuid(Node n, CompressedVectorNode* cvp, uint64_t index) {
    //??? recommend no leading/trailing whitespace
}

void E57Validator::validateCoordinateMetadata(Node n) {
    if (n.type() != E57_STRING) {
        PRINT_MESSAGE(1000/*???*/, n, "expecting String type", NULL, 0);
        return;
    }
    //??? no use of unicode, warning
    //??? check valid WKT string
}

void E57Validator::validateExtensionElement(Node n, CompressedVectorNode* cvp, uint64_t index) {
    /// Make sure is not in default namespace
    if (!n.destImageFile().isElementNameExtended(n.elementName()))
        PRINT_MESSAGE(1000/*???*/, n, "unknown element name not in an extension", cvp, index);
}

//================================================================

void E57Validator::printMessage(int messageNumber, Node n, ustring msg, CompressedVectorNode* cvp, uint64_t index) {
    if (messageNumber < 1000 || messageNumber > 4999) {
        os_ << "InternalError: message number " << messageNumber << " is out of bounds [1000,4999]" << endl;
        return;
    }

//cout << "options_.messagesAllowed[messageNumber]=" << toString(options_.messagesAllowed[messageNumber]) << endl; //???
//cout << "messageCount_[messageNumber]=" << toString(messageCount_[messageNumber]) << endl; //???

    if (options_.messagesAllowed[messageNumber] == 0)
        return;

    /// messageCount has already been incremented in the PRINT_MESSAGE macro
    if (messageCount_[messageNumber] == options_.messagesAllowed[messageNumber]+1) {
        os_ << "More than " << toString(options_.messagesAllowed[messageNumber]);
        os_ << " messages for message number " << toString(messageNumber) << ".  Suppressing the rest." << endl;
        return;
    } else if (messageCount_[messageNumber] > options_.messagesAllowed[messageNumber])
        return;

    /// Print message onto stream
    /// E.g.   "Error 1001 in /images3d/0: required element pose not defined"
    ///        "Suspicious 3001 in /images3d/0/points/0/rowIndex: "magnitude of Integer value is suspiciously large: 10000000000000"
    if (messageNumber < 2000)
        os_ << "Error";
    else if (messageNumber < 3000)
        os_ << "Warning";
    else if (messageNumber < 4000)
        os_ << "Suspicious";
    else
        os_ << "Informational";
    os_ << " " << toString(messageNumber) << " in ";
    if (cvp == NULL)
        os_ << n.pathName();
    else
        os_ << cvp->pathName() << "/" << index << n.pathName();
    os_ << ": " << msg << endl;
}

void E57Validator::checkRequired(StructureNode sn, ustring name, CompressedVectorNode* cvp, uint64_t index) {
    if (!sn.isDefined(name))
        PRINT_MESSAGE(1000/*???*/, sn, "required child element " + name + " not defined", cvp, index);
}

//================================================================


bool validateFile(E57ValidatorOptions options, ustring fname)
{
    try {
        /// Read file from disk
        ImageFile imf(fname, "r");

        E57Validator validator = E57Validator(options);
        validator.validate(imf);

        cout << "Error count:           " << toString(validator.errorCount()) << endl;
        cout << "Warning count:         " << toString(validator.warningCount()) << endl;
        cout << "Suspicious count:      " << toString(validator.suspiciousCount()) << endl;
        cout << "Informational count:   " << toString(validator.informationalCount()) << endl;

        /// Total up all errors and unsuppressed warnings and suspicious messages
        uint64_t messageCount = validator.errorCount();
        for (int i = 2000; i < 4000; i++) {
            if (options.messagesAllowed[i] > 0)
                messageCount += validator.messageCount(i);
        }
        return(messageCount > 0);
    } catch(E57Exception& ex) {
        ex.report(__FILE__, __LINE__, __FUNCTION__);
    } catch (std::exception& ex) {
        cerr << "Got an std::exception, what=" << ex.what() << endl;
    } catch (...) {
        cerr << "Got an unknown exception" << endl;
    }
    return(false);
}

int main(int argc, char** argv)
{
#if 1
    CommandLineOptions cmdLineOptions;
    cmdLineOptions.parse(argc, argv);

    bool gotError = false;
    for (size_t i = 0; i < cmdLineOptions.inputFileNames.size(); i++) {
        if (cmdLineOptions.inputFileNames.size() > 1)
            cout << cmdLineOptions.inputFileNames[i] << ":" << endl;

        if (!validateFile(cmdLineOptions.options, cmdLineOptions.inputFileNames[i]))
            gotError = true;
    }

    return(gotError ? -1 : 0);
#else
    CommandLineOptions cmdLineOptions;
    cmdLineOptions.parse(argc, argv);

    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/libe57/dist3b/trunk/foo.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/2398_400.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/43069_69_81.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/43069_69_84.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Barrow_SeaIce_May7_2008.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/ComplexSRSInfo.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Grass Lake Small.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/IowaDNR-CloudPeakSoft-1.0-UTM15N.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LAS12_Sample_withIntensity_Quick_Terrain_Modeler.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LAS12_Sample_withRGB_Quick_Terrain_Modeler.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LASFile_1.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LASFile_2.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LASFile_3.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LASFile_4.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LDR030828_211804_0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LDR030828_212242_0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LDR030828_212622_0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LDR030828_213023_0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LDR030828_213450_0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LDR030828_213842_0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/LDR030828_214222_0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Lincoln.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/MARS_Sample_Filtered_LiDAR.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Mount St Helens Nov 20 2004.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Mount St Helens Oct 4 2004.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/MtStHelens.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/N1440375.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/N1440380.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/N1445375.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/N1445380.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Palm Beach Post Hurricane.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Palm Beach Pre Hurricane.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Serpent Mound Model LAS Data.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/Srsota000011.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/USACE_Merrick_lots_of_VLRs_with_classes.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/las10_format0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/las10_format1.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/las11_format0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/las11_format1.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/las12_format0.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/las12_format1.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/las12_format2.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/libLAS_1.2.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/lt_srs_rt.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/mscst000131.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/ncwc000008.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/radiohead_data1.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/radiohead_data2.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/test.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/xyzrgb_manuscript.e57");
    validateFile(cmdLineOptions.options, "C:/kevin/astm/DataFormat/LAS/examples/xyzrgb_manuscript_detail.e57");
    return(0);
#endif
};

#if 0
// hash_map_find.cpp
// compile with: /EHsc
#include <hash_map>
#include <iostream>

int main( )
{
   using namespace std;
   using namespace stdext;
   hash_map <int, int> hm1;
   hash_map <int, int> :: const_iterator hm1_AcIter, hm1_RcIter;
   typedef pair <int, int> Int_Pair;

   hm1.insert ( Int_Pair ( 1, 10 ) );
   hm1.insert ( Int_Pair ( 2, 20 ) );
   hm1.insert ( Int_Pair ( 3, 30 ) );

   hm1_RcIter = hm1.find( 2 );
   cout << "The element of hash_map hm1 with a key of 2 is: "
        << hm1_RcIter -> second << "." << endl;

   // If no match is found for the key, end( ) is returned
   hm1_RcIter = hm1.find( 4 );

   if ( hm1_RcIter == hm1.end( ) )
      cout << "The hash_map hm1 doesn't have an element "
           << "with a key of 4." << endl;
   else
      cout << "The element of hash_map hm1 with a key of 4 is: "
           << hm1_RcIter -> second << "." << endl;

   // The element at a specific location in the hash_map can be found
   // using a dereferenced iterator addressing the location
   hm1_AcIter = hm1.end( );
   hm1_AcIter--;
   hm1_RcIter = hm1.find( hm1_AcIter -> first );
   cout << "The element of hm1 with a key matching "
        << "that of the last element is: "
        << hm1_RcIter -> second << "." << endl;
}
#endif


#if 0
int main() {
    GroupTable groups;

    groups.insert(GroupTable::value_type(1, GroupInfo(1,0.0,1.0)));
    groups.insert(GroupTable::value_type(2, GroupInfo(2,0.0,2.0)));
    groups.insert(GroupTable::value_type(3, GroupInfo(3,0.0,3.0)));

    GroupTable::iterator iter;
    for (iter = groups.begin(); iter != groups.end(); iter++) {
        iter->second.lineIndex += 10;

        std::cout << iter->first << " is " << iter->second.lineIndex << std::endl;
    }

    iter = groups.find(2);
    if (iter != groups.end()) {
        GroupInfo& gi = iter->second;
        std::cout << "find(2) is " << gi.lineIndex << std::endl;
    }
}
#endif

